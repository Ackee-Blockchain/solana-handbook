{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Solana Handbook"},{"location":"#learn-the-fundamentals-of-solana","title":"Learn the fundamentals of Solana!","text":"<p>This handbook was written for developers, auditors and anyone interested in how Solana works. Starting with the basics and terminology, it gradually introduces more advanced topics, providing a comprehensive overview without going too in-depth.</p> <p>Good luck, and enjoy the journey!</p> <p></p> <ul> <li> <p> Solana Basics</p> <p>Learn the basics of Solana blockchain.</p> <p>Solana Basics</p> </li> <li> <p> Core Concepts</p> <p>Solana can be described by the eight core concepts that make it unique and fast.</p> <p>Core Concepts</p> </li> <li> <p> Programming Model</p> <p>Explore Solana's programming model.</p> <p>Programming Model</p> </li> <li> <p> Solana Program Library</p> <p>Collection of programs that simplify tasks like token creation, management, and more.</p> <p>Solana Program Library</p> </li> </ul>"},{"location":"#about-authors","title":"About Authors","text":"<p>This handbook was created with love by Solana Auditors and Developers of Ackee.</p> <p>Ackee is a blockchain security company founded in 2021, specializing in audits and other security assessments.</p> <p>To strengthen the blockchain ecosystem, the team develops an open-source framework Trident. Additionally, they share their knowledge through free certification courses:</p> <ul> <li>School of Solana</li> <li>Solana Auditors Bootcamp</li> </ul>"},{"location":"handbook/appendices/","title":"Appendices","text":"<p>Discover additional resources and information about various aspects of Solana.</p> <p></p> <ul> <li> <p> Ecosystem</p> <p>A short description of different project types on Solana.</p> <p>Ecosystem</p> </li> <li> <p> NFTs</p> <p>Additional information about Non-Fungible Tokens.</p> <p>NFTs</p> </li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/","title":"Popular Projects","text":"<p>Solana's blockchain has become a fertile ground for innovation. Here is a list of project types that you can find, but keep in mind, this is just the tip of the iceberg. There are many more applications thriving on the Solana platform, helping the ecosystem grow and evolve.</p> Decentralized Exchanges <p>Decentralized exchanges (DEXs) allow users to trade assets directly with one another without needing a middleman or some central authority. Unlike traditional exchanges, where the exchange controls the user's funds, DEXs use smart contracts to handle the trade. While this offers benefits like reduced risk of hacking, DEXs may face challenges such as lower liquidity and higher fees. Nevertheless, they represent a significant step towards a more decentralized and transparent financial system.</p> Liquid Staking <p>Liquid staking lets users stake their assets while still being able to use them. It allows participants to earn staking rewards without locking up their tokens, by giving them synthetic or derivative tokens in return. This flexibility encourages greater participation and makes proof of stake networks more efficient.</p> Decentralized Lending <p>Decentralized lending is when people lend and borrow money directly from each other on blockchain networks. Thanks to smart contracts, there is no need for banks or middlemen. This makes borrowing and lending easier, sometimes cheaper and gives users more control over their finances.</p> Marketplaces <p>There are multiple NFT marketplaces where people can trade and buy NFTs, which are meant to act as certificates of ownership. NFTs have useful applications in representing real-world items, such as concert tickets.</p> Analytics Tools <p>Analytics tools on blockchain provide insights into transactions, network health, and user behavior. They improve transparency, traceability, and help people make better decisions.</p> Gaming <p>Having a 400ms block time and lightning-fast confirmations makes Solana a real-time database. It is perfect for genres like strategy games, city builders or turn-based games. However, not everything needs to be put on the blockchain. Some smaller integrations, like using NFTs that represent game items, can offer a lighter approach. Transaction fees are cheap, and there are many tools and SDKs available to start building today.</p> Bridges <p>Cross-chain bridges have various use cases, such as transferring data and enabling smart contracts on different networks to interact. Bridges are best known for facilitating movement of assets across different blockchain networks. The bridge locks an asset on the original blockchain and then creates an equivalent token on the destination blockchain. This way the value is transferred without moving the original asset.</p>"},{"location":"handbook/appendices/appendixB/metadata-off-chain/","title":"Storing Metadata Off-chain","text":"<p>One important attribute of the metadata account is the URI attribute that points to a JSON file off-chain. This is used to safely provide additional data whilst not being constrained by the fees involved in storing on-chain data. That JSON file follows a certain standard that anyone can use to find useful information on tokens.</p> <p>Note</p> <p>The JSON file can be stored using a permanent storage solution such as Arweave to ensure it cannot be updated. Additionally, one can use the Is Mutable attribute of the metadata account to make it immutable.</p> Arweave <p>Arweave is a decentralized, trust-minimized, censorship-resistant data storage network designed to retain data permanently, making it a great fit for NFTs. To cover the cost of storing your media forever, storage and mining fees are paid at the time of upload and distributed to storage providers participating in the network.</p> Storage Fees <p>Storage fees are based on the total size of the files you upload to the network during NFT creation. Each NFT consists of three files:</p> <ul> <li>The asset (image, video, audio, etc).</li> <li>The accompanying metadata file (attributes etc.).</li> <li>A generated manifest which creates a logical grouping or relationship between your files.</li> </ul> <p>The cumulative size of these files (in bytes) is submitted to the Arweave storage cost estimation service which returns the real time estimated fee for storage, priced in winstons. We then convert the winstons to SOL for payment.</p>"},{"location":"handbook/appendices/appendixB/metaplex/","title":"Metaplex","text":"<p>Metaplex is a decentralized protocol built on the Solana blockchain designed to simplify the creation, sale, and use of NFTs. By offering a suite of development tools, smart contracts, and open standards, Metaplex enables NFT communities to issue, manage, and own digital assets on-chain.</p> <p>Metaplex continuously develops and maintains several programs and standards to enhance user experience and meet the evolving needs of its community.</p> Candy Machine <p>Candy Machine is one of the Metaplex protocols. It is a minting and distribution program for fair NFT collection launches on Solana. Much like its name suggests, you can think of a Candy Machine as a temporary structure which is first loaded by creators and then unloaded by buyers. It allows creators to bring their digital assets on-chain in a secure and customizable way.</p> <p>Note</p> <p>The name refers to the vending machines that dispense candy for coins via a mechanical crank. In this case the candy are NFTs and the payment is SOL or a SPL token.</p> <p>Info</p> <p>By September 2022, 78% of all NFTs on Solana were minted through Metaplex\u2019s Candy Machine.</p> <p>Here are some of its features:</p> <ul> <li>Accept payments in SOL, NFTs or any Solana token.</li> <li>Restrict your launch via start/end dates, mint limits, third party signers, etc.</li> <li>Protect your launch against bots via configurable bot taxes and gatekeepers like captchas.</li> <li>Restrict minting to specific NFT/Token holders or to a curated list of wallets.</li> <li>Create multiple minting groups with different sets of rules.</li> </ul> <p></p>"},{"location":"handbook/appendices/appendixB/non-fungible-tokens/","title":"Non-Fungible Tokens","text":"<p>Non-Fungible Tokens (NFTs) on Solana are represented by mint accounts with the following characteristics:</p> <ul> <li>It has a supply of 1, meaning only one token is in circulation.</li> <li>It has zero decimals, meaning there cannot be such a thing as 0.5 tokens.</li> <li>It has no mint authority, meaning no one can ever mint additional tokens.</li> </ul> <p></p>"},{"location":"handbook/appendices/appendixB/token-metadata-program/","title":"Token Metadata Program","text":"<p>The Token Metadata program is one of the most important programs when working with NFTs. Its main goal is to attach additional data to fungible or non-fungible tokens on Solana.</p> <p>It achieves this using PDAs that are derived from the address of mint accounts.</p> <p>Important</p> <p>Mint accounts are responsible for storing the global information of a token and token accounts store the relationship between a wallet and a mint account.</p> Metadata Account <p>Whilst mint accounts contain a few data attributes such as its current supply, they cannot hold standardized data that can be understood by apps and marketplaces. This is why the Token Metadata program offers a metadata account that attaches itself to a mint account via a PDA.</p> <p></p> Master Edition <p>Additionally, the Token Metadata program offers another account specifically for NFTs called the Master Edition account. This account is also a PDA derived from the mint account.</p> <p>Note</p> <p>Before creating this account, the Token Metadata program will ensure the special characteristics of NFTs are met. Thus, the existence of the Master Edition account acts as proof of non-fungibility for that mint account.</p> <p>The Master Edition account includes some additional fields that are not crucial for the main idea. In essence, Metaplex offers the capability to create copy of NFTs, with the Master Edition account serving as proof of whether an NFT is original or a copy.</p> <p></p>"},{"location":"handbook/appendices/appendixB/token-types/","title":"Token Types","text":"<p>There are more types of tokens on Solana besides fungible and non-fungible. Here are some of the token types that you can come across on Solana.</p> Semi-Fungible Tokens <p>Semi-Fungible Token has attributes of a typical NFT such as image and metadata but its supply is greater than one. These tokens are becoming popular in gaming contexts to support fungible items such as a kind of sword or a piece of wood.</p> Programmable NFT <p>Since the Token Metadata program builds on the Solana Token program, tokens (fungible or not) can be transferred without involving the Token Metadata program. Metadata accounts include a Seller Fee Basis Points field for royalties, but it\u2019s only informational. This allows marketplaces to bypass royalties, which has happened.</p> <p>Programmable NFTs were introduced to fix this. They are a new token standard that keeps token accounts frozen, ensuring transfers go through the Token Metadata program. Creators can define custom authorization rules in a RuleSet account, such as enforcing royalties. These RuleSets are part of the Token Auth Rules program.</p> <p></p> Executable NFT <p>Executable NFTs (xNFTs), available in the open source wallet Backpack, represent an entirely new way to build applications. They combine executable websites and applications that can run locally on a user\u2019s computer with a crypto wallet.</p> <p>xNFTs take a radically practical approach to solving two of web3\u2019s main problems today, decentralization and distribution. While smart contracts run on globally distributed and decentralized networks like Solana, nearly everyone who interacts with smart contracts does so through a website.</p> <p>Example</p> <p>Executable NFTs can bring a new level of interactivity to traditional collections. The first xNFT Collection, Mad Lads, showcases the power of an executable profile picture collection \u2014 the pictures themselves act as a chatroom for users which is rendered entirely within the NFT. The possibilities are almost limitless.</p> <p></p> Compressed NFT <p>Compressed NFTs use state compression and Merkle trees to drastically reduce the storage cost for NFTs. Instead of storing metadata in a typical Solana account, compressed NFTs store the metadata within the ledger. This allows compressed NFTs to still inherit the security and speed of the Solana blockchain, while at the same time reducing the overall storage costs.</p> <p>Even though the on-chain data storage mechanism is different than their uncompressed counterparts, compressed NFTs still follow the exact same metadata schema/structure. Allowing you to define your collection and NFT in an identical way.</p> <p>Note</p> <p>Minting 100 million compressed NFTs costs about 50 SOL to store on-chain, compared to 1.2mm SOL for their uncompressed counterpart. Every incremental compressed NFT is solely a modification of an existing tree, which brings the cost down to as little as 0.000005 SOL.</p>"},{"location":"handbook/chapter1/","title":"Solana Introduction","text":"<p>Learn what Solana is and understand basic blockchain terminology, from blocks to smart contracts.</p> <p></p> <ul> <li> <p> Introduction</p> <p>A short introduction to Solana.</p> <p>Introduction</p> </li> <li> <p> Blockchain</p> <p>Learn what is a blockchain.</p> <p>Blockchain</p> </li> <li> <p> Transaction</p> <p>Learn what transactions are and how they relate to instructions.</p> <p>Transaction</p> </li> <li> <p> Infrastructure</p> <p>Explore essential components that run the network.</p> <p>Infrastructure</p> </li> <li> <p> Security</p> <p>See how Solana ensures network security and consensus integrity.</p> <p>Security</p> </li> <li> <p> Slots, Epochs and Leaders</p> <p>Learn about Solana's time structure and leader rotation.</p> <p>Slots, Epochs and Leaders</p> </li> <li> <p> Smart Contract</p> <p>A program deployed on a blockchain.</p> <p>Smart Contract</p> </li> <li> <p> Ecosystem</p> <p>Solana is not just a currency!</p> <p>Ecosystem</p> </li> </ul>"},{"location":"handbook/chapter1/blockchain/","title":"Blockchain","text":"Block <p>Block is a data structure that contains a header and a set of transactions. Header is comprised of three items \u2013 the hash of the previous block\u2019s header, metadata and a Merkle root. Metadata depends on the protocol. The Merkle root is a root of the well-known Merkle tree, which can be used to verify later that transactions in a block have not been tampered with.</p> Blockchain <p>A blockchain can be thought of as a series of blocks or an append-only data structure that resembles an ordered back-linked linked list, which uses hashes as pointers to previous blocks. This structure consists of blocks that form a chain, hence the term blockchain.</p> <p></p> <p>Important</p> <p>Header is used to maintain the blockchain's integrity. If any part of the header changes, the hash will change, breaking the link to subsequent blocks.</p>"},{"location":"handbook/chapter1/ecosystem/","title":"Ecosystem","text":"Beyond Currency <p>While many people associate Solana primarily with its native cryptocurrency SOL, it is important to understand that Solana is far more than just a digital currency. Solana is a high-performance blockchain network and an ecosystem that supports a wide array of dApps and use cases. Its architecture is designed for scalability, offering high throughput of up to 65,000 transactions per second, cheap fees and lightning-fast confirmations, making it suitable for demanding applications like decentralized finance (DeFi), non-fungible tokens (NFTs), gaming, and more.</p> Decentralized Supercomputer <p>Think of Solana like a vast, decentralized supercomputer spread across the globe. This network is like one huge, shared computer that anyone can use. The blockchain in this system acts like the computer's memory, storing all the information and transactions. Just as your personal computer runs programs, Solana can run dApps. The SOL is like the fuel that powers this computer, used to pay for using its resources. Validators in the network are similar to the different components of a computer, working together to process information.</p> Interconnected dApps <p>When making a dApp, developers can use other dApps that are already deployed on the network and incorporate them in their projects.</p> <p>Example</p> <p>Let's say you want to make an online fantasy trading card game. Instead of coding everything from scratch, you could:</p> <ol> <li>Use an existing dApp that creates unique digital cards (as NFTs).</li> <li>Add another dApp that handles in-game currency and player transactions.</li> <li>Include a dApp that manages player rankings and tournaments.</li> </ol> <p>This is what makes Solana powerful. There are already many tools and dApps that are waiting for people to use and build upon.</p>"},{"location":"handbook/chapter1/infrastructure/","title":"Infrastructure","text":"Nodes <p>Node is a single participant in a network. The nodes communicate with each other according to the protocol and in a peer-to-peer manner forming the whole blockchain network.</p> <p>Different kinds of nodes serve different purpose:</p> <ul> <li>Validator nodes secure the network by proposing new blocks and voting on the validity of new blocks.</li> <li>RPC (Remote Procedure Call) nodes do not participate in voting, they query the network and post new transactions.</li> </ul> Validator clients <p>The software that runs on validator nodes is called validator client. If all validators used the same client, a bug or exploit within that client could compromise the whole network. By using different clients, we spread out the risk. This way, if one client has an issue, the network can still stay safe and keep running smoothly.</p> <p>Important</p> <p>Validator client diversity increases resilience and security of the network.</p> <p>As of now, there are four validator clients (some in development):</p> <ul> <li>Agave</li> <li>Jito Labs</li> <li>Firedancer</li> <li>Sig</li> </ul> Protocol <p>Protocol is a common set of rules network nodes must follow. It defines things like:</p> <ul> <li>Communication between P2P (peer-to-peer) nodes.</li> <li>Transaction format for network participants.</li> <li>Any special features.</li> <li>Everything else for the network to operate correctly and for the users to know how to transact over the network.</li> </ul> <p>An essential part of a good protocol for a decentralized blockchain network is the proper incentive setup, which creates the need for its native coin.</p> Coin <p>Coins are used to motivate participation in the network. They are usually awarded to miners or validators with every new block for their role in securing the network and validating transactions. Without the proper incentives, any decentralized blockchain network falls apart.</p> <p>Info</p> <p>The Solana blockchain's native currency is SOL. Within Solana, the smallest unit is called a lamport, where 1 SOL equals 1,000,000,000 lamports.</p>"},{"location":"handbook/chapter1/introduction/","title":"Introduction","text":"<p>Solana is a blockchain platform that allows people to build and use decentralized applications (dApps) and cryptocurrencies. It was created in 2017 by Anatoly Yakovenko and officially launched its mainnet beta in March 2020.</p> Blockchain Trilemma <p>The blockchain trilemma refers to a problem that blockchains face when trying to achieve three important things at once:</p> <ul> <li>Scalability: Being fast and able to handle many transactions.</li> <li>Security: Ensuring the system is resistant to attacks.</li> <li>Decentralization: Controlled by many people instead of just one group.</li> </ul> <p>Usually, improving one of these aspects can make the others weaker. For example, if a blockchain is very secure and decentralized, it might struggle to process transactions quickly. The main value proposition of Solana is solving the blockchain trilemma, i.e., delivering scalability, decentralization, and security without sacrificing any of the three mentioned features.</p> Development on Solana <p>Solana\u2019s ecosystem revolves around the Rust programming language and its ecosystem. Although Rust is the primary language for smart contract development, C and C++ are also supported.</p> <p>Note</p> <p>Solana also provides libraries and tools for JavaScript and TypeScript developers to interact with the blockchain.</p>"},{"location":"handbook/chapter1/security/","title":"Security","text":"Sybil Resistance <p>To prevent a single entity from taking over the network, there must be a mechanism put in place so that no one can just spawn more nodes that can mine or vote (depending on the network) and thus subvert the network reputation system. These dishonest nodes would be able to out-vote honest nodes and start censoring transactions, approving invalid transactions, or changing the entire protocol.</p> <p>Currently, the two most common Sybil resistance mechanisms are:</p> <ul> <li> <p>Proof-of-Work (PoW) employs a model where miners in the network are given a chance to mine a block that is proportional to their hashing power in the network. Miners basically compete with each other which makes PoW-based networks very energy-inefficient. Bitcoin uses PoW mechanism.</p> </li> <li> <p>Proof-of-Stake (PoS) is a type of model for voting-based networks, where a validator is given the power of their vote proportionally to staked coins. In each round one validator is randomly chosen to propose a new block, while others validate it. By eliminating competition among validators, PoS-based networks are significantly more energy-efficient.</p> </li> </ul> Consensus <p>To agree on a certain state of a blockchain, network nodes need to reach a consensus. We assume there are malicious nodes in the network. Therefore, the system must be able to withstand not only simple node failures but also attacks to a certain extent. Byzantine Fault Tolerance (BFT) is thus a desired property of such a distributed system.</p> <p>There are three widely used consensus families:</p> <ul> <li>PBFT-like (Practical BFT) algorithm family: Nodes achieve consensus through a series of voting rounds which ensures that the network can function properly even if some nodes are malicious or fail.</li> <li>Nakamoto consensus: This family combines Proof-of-Work with the longest-chain rule. It was invented by Satoshi Nakamoto in 2008.</li> <li>Avalanche Consensus: A new family introduced in 2018. It is a method where network is quickly able to reach consensus by having nodes communicate with small groups of other nodes.</li> </ul> Security <p>Consensus and Sybil resistance mechanisms are often confused as being the same thing, which is not true and is worth pointing out. One works in conjunction with the other. Let\u2019s look at how this works in both PoW-based and PoS-based networks.</p> <p>Consider what makes Bitcoin, a PoW-based network, theoretically secure \u2013 it is the fact that only the longest chain is respected, also commonly known as the longest chain rule. This is why the consensus is called, as mentioned before, the Nakamoto consensus.</p> <p>For a PoS-based network, the Sybil resistance mechanism is usually associated with a variant of a PBFT-like algorithm or the novel Avalanche consensus.</p> <p>Important</p> <p>Solana uses Proof-of-Stake mechanism coupled with a timekeeping protocol called Proof-of-History.</p> Threat Scenarios on BFT networks <p>In Byzantine Fault Tolerant (BFT) networks, threat scenarios involve attempts to disrupt the consensus process by taking control of validator nodes.</p> <p>Warning</p> <p>1/3 Attack</p> <p>If an attacker controls just over one-third of the network\u2019s validators, they can prevent the network from reaching consensus, which effectively halts the network.</p> <p>2/3 Attack</p> <p>The scenario where an attacker controls more than two-thirds of the validators is even more dangerous. This allows them not only to halt the network but also to take over, potentially rewriting the blockchain and compromising its security.</p> <p>It is crucial to maintain validator diversity and decentralization in order to prevent these attacks.</p>"},{"location":"handbook/chapter1/slots-epochs-leaders/","title":"Slots, Epochs and Leaders","text":"Slots <p>A slot is a 400 milliseconds long time interval, during which a specific validator, known as the leader, is given a chance to propose a new block. This block contains transactions that are ready to be processed within the network. After the block is proposed, other validators review and confirm its validity.</p> <p>Note</p> <p>If a leader fails to propose a block during their assigned slot, the network moves on to the next validator in line.</p> Epochs <p>An epoch is a fixed time period lasting approximately 432,000 slots (about 2 days). Epochs serve as a fundamental unit of time in Solana's ecosystem. They are used to manage stake activations and deactivations, and most importantly, to determine the schedule for leader rotation. At the beginning of each epoch, the network recalculates validator stakes and updates the leader schedule for the upcoming period.</p> <p>Info</p> <p>The probability of a given validator being chosen as a leader is proportional to their stake in the network.</p>"},{"location":"handbook/chapter1/smart-contract/","title":"Smart Contract","text":"<p>A smart contract is a piece of code deployed on a blockchain with a cryptographically signed transaction. Users can then interact with it by sending transactions that invoke a specific function defined in the smart contract and the business logic is executed as stated in the deployed code.</p> <p>Data relevant to the smart contract state are also stored on the blockchain. Hence we can look at smart contracts as programs on a decentralized computer that access files in its file system and modify them according to the predefined rules. If such a contract is made immutable, we can trust that the smart contract will do nothing other than what it is supposed to do.</p> <p>Note</p> <p>Apart from storing the blockchain itself, each node creates a state as a result of transaction execution. The final state is the result of all processed transactions and can always be deterministically recreated from the blockchain history.</p> ISA and Virtual Machines <p>Code is compiled for a predefined Instruction Set Architecture (ISA) and executed in a Virtual Machine (VM) which understands it. The mentioned VM is a special runtime environment similar to well-known VMs such as Java Virtual Machine (JVM) or Common Language Runtime (CLR).</p> <p>Info</p> <p>The Solana blockchain's execution environment is called Solana Virtual Machine (SVM). It is written in Rust and enables the blockchain to handle thousands of transactions per second.</p> <p>Note</p> <p>Only transactions involving smart contract execution need to be processed by the VM.</p>"},{"location":"handbook/chapter1/transaction/","title":"Transaction","text":"<p>Transaction is a protocol-defined message that is stored as a part of a block, which is then stored as a part of a blockchain. The content usually consists of some kind of value transfer or on-chain program execution. Transactions are cryptographically signed by their authors, proving their authenticity.</p> Instruction <p>A transaction is made up of one or more instructions. An instruction is a lower-level command that tells the blockchain what action to perform. These actions can include transferring tokens, interacting with smart contracts, or even creating new accounts.</p> <p>Info</p> <p>Instructions are the building blocks of transactions. A single transaction can contain multiple instructions, allowing it to perform complex operations in one go.</p>"},{"location":"handbook/chapter2/","title":"Core Concepts","text":"<p>Learn the key features that make Solana so fast, efficient and scalable. These eight core concepts are what makes Solana stand out from other blockchains!</p> <p></p> <ul> <li> <p> Proof of History</p> <p>A cryptographic clock that timestamps transactions.</p> <p>Proof of History</p> </li> <li> <p> Tower BFT</p> <p>A consensus mechanism that ensures finality using PoH as a clock reference.</p> <p>Tower BFT</p> </li> <li> <p> Turbine</p> <p>A block propagation protocol that breaks data into smaller packets for faster transmission.</p> <p>Turbine</p> </li> <li> <p> Gulf Stream</p> <p>A mempool system that pushes transactions to validators before confirmation.</p> <p>Gulf Stream</p> </li> <li> <p> Sealevel</p> <p>Solana\u2019s parallel smart contract runtime for simultaneous transaction execution.</p> <p>Sealevel</p> </li> <li> <p> Pipelining</p> <p>A technique that optimizes transaction processing.</p> <p>Pipelining</p> </li> <li> <p> Cloudbreak</p> <p>Solana's custom database that enables fast reads and writes.</p> <p>Cloudbreak</p> </li> <li> <p> Archivers</p> <p>Distributed storage systems that hold and serve off-chain data for Solana\u2019s ledger.</p> <p>Archivers</p> </li> </ul>"},{"location":"handbook/chapter2/archivers/","title":"Archivers","text":"<p>The Solana blockchain can grow at enormous speed, making it very challenging for each node to store the complete history of transactions. To address this, there is a concept of distributed ledger storage that would store this data in a decentralized fashion for everyone else.</p> <p>Insight</p> <p>At the network speed of 1 Gbps, the Solana blockchain would generate roughly 4 petabytes of data over the course of 1 year.</p> <p>Given how impractical it would be for every validator to keep a full copy of blockchain's history, the idea is to offload the data from validators to these specialized, lightweight network nodes called Archivers. The data is split into many small pieces and replicated so that the full state can always be reconstructed. These specialized nodes are also regularly challenged at the protocol level using a mechanism called Proof of Replication. This ensures that nodes store the correct data and prevents data loss.</p> <p>Note</p> <p>This concept is yet to be implemented.</p>"},{"location":"handbook/chapter2/cloudbreak/","title":"Cloudbreak","text":"Memory Bottleneck <p>As the speed of computation increases, memory access becomes a new bottleneck. LevelDB is the industry-standard local database for storing blockchain data and state. However, it does not support parallel reads and writes. That is fine for Bitcoin or Ethereum, but not for a massively parallel system like Solana.</p> <p>The sheer size of the blockchain state makes storing everything in RAM impractical even for large servers. To combat this, Solana had to invent its own database system that supports parallel reads and writes and scales easily with addition of more disks.</p> Cloudbreak <p>Cloudbreak is Solana's custom database. It makes use of memory-mapped files to store data in a way that allows for independent access to each file.</p> <p>Info</p> <p>A memory-mapped file is a file that is mapped to the process\u2019s virtual memory address space and can be accessed directly without further system calls.</p> <p>The speed is still limited by the disk I/O, but we get less overhead, and the kernel can store a part of it in its page cache (also known as file cache).</p> <ul> <li>Reads are randomly distributed among available disks, as the data is stored evenly.</li> <li>Writes use Copy-on-Write semantics, appending new data sequentially to random disks.</li> </ul> <p>Old data entries are garbage collected in order to preserve space for future use. The design of Cloudbreak makes it ideal for hardware setups, such as RAID 0 with fast NVMe SSDs.</p> <p>Note</p> <p>The Cloudbreak database was benchmarked by the Solana team. The results show that even with 10 million accounts, a size that does not fit in RAM, Cloudbreak still achieves nearly 1 million of read and write operations per second with a single SSD.</p>"},{"location":"handbook/chapter2/gulf-stream/","title":"Gulf Stream","text":"Mempool <p>In traditional blockchains, each node reserves a part of its memory for the memory pool, more commonly known as mempool. The mempool is used to store transactions that are currently being broadcasted over the network but have not yet been added to a block.</p> <p>This creates a big communication overhead where every transaction must reach all nodes in the network. While not all nodes need to be aware of every transaction in the mempool, it is most important for miner and validator nodes (depending on the type of network), which must include them in new blocks.</p> <p>Note</p> <p>If there are more transactions in the mempool than can fit into a block, a backlog of pending transactions is created.</p> Gulf Stream <p>Gulf Stream is Solana\u2019s mempool-less solution for forwarding and storing transactions before processing them. Instead of having a single shared mempool, transactions are pushed to the next expected leader. This allows the next leader to quickly receive transactions and start processing them immediately.</p> <p>Info</p> <p>For this to work, the next leader must always be known in advance. In Solana, leader rotation is scheduled one full epoch ahead of time.</p>"},{"location":"handbook/chapter2/pipelining/","title":"Pipelining","text":"<p>It is not enough to be able to form a consensus and share a block with the rest of the network quickly. A node must validate and execute all those transactions in received blocks before another block comes. To address this, the Solana team developed the Transaction Processing Unit (TPU). The TPU works as a processor and extensively uses pipelining.</p> <p>Insight</p> <p>Pipelining is a common CPU optimization that helps keep the chip more utilized by splitting an instruction execution into stages. This method allows various hardware components to work in parallel, reducing idle time.</p> Stages of the TPU pipeline <ol> <li>Data fetch: Incoming data is fetched the in kernel space via network card.</li> <li>Signature verification: The GPU handles signature verification.</li> <li>Banking: Update of the state using the CPU.</li> <li>Write: The processed transaction are written to the disk in the kernel space and broadcast via network card to the network.</li> </ol> <p></p> <p>Info</p> <p>There are two pipelined processes that Solana validators use:</p> <ul> <li>The leader uses Transaction Processing Unit (TPU) to produce a new block.</li> <li>Other validators use Transaction Validation Unit (TVU) to validate and propagate the block produced by the leader.</li> </ul>"},{"location":"handbook/chapter2/proof-of-history/","title":"Proof of History","text":"<p>Achieving agreement on time in distributed systems has always been problematic. Solana uses a timekeeping protocol called Proof of History (PoH) to synchronize local virtual clocks on all nodes. PoH ensures that the timestamp in any message can be trusted and that any timeouts in the consensus protocol can be avoided because every node knows the current time and when to begin a new consensus round.</p> <p>Important</p> <p>Proof of History minimizes block time by eliminating waiting overhead. Thanks to synchronized clocks, communication can be replaced by local computation.</p> <p>To prevent validators from skipping their predecessors, PoH is used to force all validators to complete some computational work making them wait specific amount of time before they can submit their block.</p> <p>Example</p> <p>If validator B follows validator A, B cannot attempt to skip A's block by chaining off the previous block because B has to run the PoH algorithm for at least as long as A did. This gives validator A a fair chance to submit their block.</p> <p>Warning</p> <p>Proof of History is neither a consensus mechanism nor a Sybil resistance mechanism!</p> Verifiable Delay Function <p>PoH is based on a Verifiable Delay Function (VDF). Solana uses a recursive, pre-image-resistant SHA-256 VDF, where the output of one SHA-256 iteration is recursively used as the input for the next.</p> <p>To create a block, the producer needs to compute the VDF with all new messages to be included in the block:</p> <pre><code>Message<sub>1</sub> \u2192 Hash<sub>1</sub> \nHash<sub>1</sub> + Message<sub>2</sub> \u2192 Hash<sub>2</sub> \nHash<sub>2</sub> + Message<sub>3</sub> \u2192 Hash<sub>3</sub> \n... \nHash<sub>n-1</sub> + Message<sub>n</sub> \u2192 Hash<sub>n</sub></code></pre> <p>Note</p> <p>Using PoH, we are able establish the exact order of messages because we can prove that Message<sub>n</sub> occured after Message<sub>n-1</sub> and before Message<sub>n+1</sub>.</p> Phases of PoH <ul> <li> <p>Evaluation phase (leader):</p> <p>During this phase computation takes place on only one CPU core, as PoH requires strictly sequential processing by definition.</p> <p>This phase takes:</p> </li> </ul> \\[ \\frac{total\\ number\\ of\\ hashes}{hashes\\ per\\ second\\ for\\ single\\ core} \\] <ul> <li> <p>Verification phase (voters):</p> <p>In verification phase, blocks can be checked in parallel using GPU with thousands of cores since the intermediate hashes are known.</p> <p>This phase takes:</p> </li> </ul> \\[ \\frac{total\\ number\\ of\\ hashes}{hashes\\ per\\ second\\ for\\ single\\ core \\times number\\ of\\ cores\\ available} \\] <p>Important</p> <p>The key takeaway is that while PoH is computationaly intensive to produce, it can be verified very quickly by validators.</p>"},{"location":"handbook/chapter2/sealevel/","title":"Sealevel","text":"<p>Sealevel is a runtime developed by the Solana team that allows for the parallel processing of smart contracts. It can process as many transactions as many cores are available in the system. This is a major improvement, making Solana a multi-threaded global state machine.</p> <p>Important</p> <p>A high-level overview of how Sealevel works:</p> <ul> <li>Sort pending transactions.</li> <li>Schedule non-overlapping transactions to run in parallel.</li> </ul> <p>The reason this is possible with Solana is that each and every transaction explicitly defines states it will read from and write to. Sealevel can then choose non-overlapping instructions to be executed in parallel. Additionally, transactions that only read certain states can be executed in parallel as well.</p> <p>Note</p> <p>Other blockchains operate as single-threaded global state machines. The only thing they might do in parallel is signature verification.</p> Berkeley Packet Filter <p>The standard way to execute code on a blockchain is to use a Virtual Machine (VM) and compile the code, written in various supported languages, into bytecode. This code then gets deployed to the blockchain, and when the user sends a transaction invoking the contract, the code gets loaded into the VM and executed.</p> <p>Ethereum does this using its own Ethereum Virtual Machine (EVM). Some other blockchains make use of Web Assembly (WASM). Solana iterated through several solutions and chose a variant of the Berkeley Packet Filter (BPF) for its virtual machine.</p> <p>Sealevel hands off transactions to the VM, where they are executed as BPF bytecode. BPF and its extended version, eBPF, originally designed for high-performance packet filtering in networking systems, are in-kernel VMs available in most UNIX-like operating systems.</p> <p>Important</p> <p>Solana uses Rust Berkeley Packet Filter (rBPF) which is a modified version of eBPF optimized for Solana's architecture.</p>"},{"location":"handbook/chapter2/tower-bft/","title":"Tower BFT","text":"Tower Byzantine Fault Tolerance <p>Solana uses Tower Byzantine Fault Tolerance (TBFT) as its consensus algorithm, which is a custom implementation of the Practical Byzantine Fault Tolerance (PBFT) algorithm published in 1999 by Miguel Castro and Barbara Liskov.</p> <p>The goals of PBFT are to ensure:</p> <ul> <li>Safety: Results are valid and identical across all non-faulty nodes.</li> <li>Liveness: Nodes that don\u2019t fail will always produce a result.</li> </ul> <p>Note</p> <p>Safety is guaranteed because the process is deterministic, meaning it always produces the same results across all non-faulty nodes. The liveness guarantee is enabled by the view-change mechanism, which allows nodes to switch leaders if the current leader appears to be malicious or faulty.</p> View-change <p>View-changes occur when a leader appears to have failed, and so another node attempts to take his place by initiating an election process. This process is triggered by timeouts that prevent nodes from waiting indefinitely for unexecuted requests. The timeout is postponed whenever the protocol detects that nodes are nearing agreement on the current block.</p> TBFT vs PBFT <p>TBFT is a variation of PBFT, with one key difference. Proof of History provides a global source of time before consensus is reached and can therefore be used to enforce the exponentially increasing timeouts introduced in the original PBFT algorithm. No additional messages are needed because PoH itself enforces the timeouts, thereby reducing communication overhead.</p>"},{"location":"handbook/chapter2/turbine/","title":"Turbine","text":"<p>Turbine is a block propagation protocol designed to reduce both time needed for block propagation as well as the overall message complexity, reducing the communication overhead of a node.</p> <p>Nodes in the network are divided into small partitions called neighborhoods. Nodes within a particular neighborhood are responsible for sharing received data with other nodes in the same neighborhood and propagating the data to a small number of nodes in other neighborhoods.</p> <p> </p> <p>Info</p> <p>The data unit shared is called a shred, and each block is composed of many shreds.</p> Problems with Broadcasting <p>Since we are in an adversarial environment, any node can decide not to rebroadcast the received shreds or broadcast incorrect data.</p> <p>Countermeasures:</p> <ul> <li> <p>Erasure Codes help by broadcasting a block with more shreds than necessary to reconstruct the entire block without errors, even if some shreds are lost along the way. With 6 data shreds and 3 additional redundant shreds, we can lose up to 1/3 of the shreds and still be able to reconstruct the entire block fully.</p> </li> <li> <p>A stake-weighted selection algorithm is used to create a tree where the risk of faulty or malicious nodes is minimized. Validators with the highest stake are positioned closer to the current leader.</p> </li> </ul>"},{"location":"handbook/chapter3/","title":"Programming Model","text":"<p>Learn how to interact with the network and dive into concepts like transactions, accounts, and runtime policy that define how programs operate on Solana.</p> <p></p> <ul> <li> <p> Interacting with the Network</p> <p>Learn how to interact with Solana's blockchain using different tools.</p> <p>Interacting with the Network</p> </li> <li> <p> Transaction Lifecycle</p> <p>Explore the journey of a transaction on Solana.</p> <p>Transaction Lifecycle</p> </li> <li> <p> Transaction Anatomy</p> <p>Understand what makes up a transaction on Solana.</p> <p>Transaction Anatomy</p> </li> <li> <p> Account Anatomy</p> <p>Learn the structure of accounts as well as their purpose.</p> <p>Account Anatomy</p> </li> <li> <p> Runtime Policy</p> <p>Learn the rules enforced by Solana\u2019s runtime to ensure system security.</p> <p>Runtime Policy</p> </li> <li> <p> Program Derived Address</p> <p>Understand program derived addresses and how they differ from regular pubkeys.</p> <p>Program Derived Address</p> </li> <li> <p> Cross Program Invocation</p> <p>Explore how programs on Solana interact with each other.</p> <p>Cross Program Invocation</p> </li> </ul>"},{"location":"handbook/chapter3/account-anatomy/","title":"Account Anatomy","text":"Everything is an Account <p>Just as in UNIX, where \"everything is a file\", in Solana \"everything is an account\". In other words, an account is a memory buffer that functions similarly to a file in a file system. The main purpose of an account is to store state between instructions and transactions. Each account is identified by an address (a public key) and Solana\u2019s account system can therefore be viewed as  key-value database.</p> <p>Note</p> <p>The key may be one of the following:</p> <ul> <li>An ed25519 public key.</li> <li>A program derived address (PDA).</li> </ul> Account Anatomy <p></p> <p>1. Lamports</p> <ul> <li>The account balance is held in lamports.</li> <li>1 lamport = 10<sup>\u22129</sup> SOL.</li> </ul> <p>2. Data</p> <ul> <li>Vector of bytes.</li> <li>The maximum account data size is 10 MB.</li> </ul> <p>Warning</p> <p>For PDAs, the limit is 10 KB at the time of creation, but they can later be resized to a maximum of 10 MB.</p> <p>3. Owner</p> <ul> <li>The owner is either a program ID or a loader in case of an executable account.</li> <li>All new accounts are owned by the System program which allows:<ul> <li>Transfer of lamports.</li> <li>Data allocation.</li> <li>Assignment of ownership to a different program ID.</li> </ul> </li> </ul> <p>Info</p> <p>Program is granted write access only if the owner matches its ID (program owns the account).</p> <p>Important</p> <p>An account is always owned either by a program or a loader.</p> <p>4. Executable</p> <ul> <li>Turning a non-executable account into an executable one is a one-way only operation.</li> <li>The owner of such an account is a loader that will load the code from the data field of the account and start executing it if invoked.</li> </ul> <p>Note</p> <p>Account becomes read-only it is made executable.</p> <p>5. Rent Epoch</p> <ul> <li>To maintain an account on Solana, a fee called rent has to be paid periodically.</li> <li>An account is considered rent-exempt if it holds at least two years\u2019 worth of rent.</li> <li>Every epoch runtime checks whether the account should pay rent or is rent-exempt.</li> </ul> Account Types <p>There are 3 types of Solana accounts:</p> <ol> <li>Data accounts: These accounts serve as containers for storing and retrieving data.</li> <li>Program accounts: These accounts store user-deployed executable bytecode.</li> <li>Native accounts: These accounts hold Solana's built-in programs such as the System program, the BPF Loader, and others.</li> </ol>"},{"location":"handbook/chapter3/cross-program-invocation/","title":"Cross Program Invocation","text":"<p>A Cross Program Invocation (CPI) is a mechanism that allows Solana programs to call other programs from within an instruction. The caller is halted until execution returns from the callee.</p> <p>Programs can extend their signer privileges to other programs using CPIs. CPIs are executed by calling either invoke or invoke_signed methods within their instructions:</p> <ul> <li>invoke - All necessary signatures are already available before the call.</li> <li>invoke_signed - Calling program needs PDAs to act as signers during the CPI.</li> </ul> <p>Info</p> <p>After a CPI to another program is made, the callee program can make further CPIs to other programs. The maximum CPI depth is 4.</p> <p>CPIs are a very powerful feature as they allow developers to make use of other deployed programs and continuously build on and expand the Solana's already existing ecosystem.</p>"},{"location":"handbook/chapter3/interacting-with-the-network/","title":"Interacting with the Network","text":"RPC Requests <p>Any user who chooses to interact with the network must communicate with one of the network\u2019s nodes through a Remote Procedure Call (RPC) endpoint. The available RPC methods are listed in the Solana documentation.</p> <p>The methods vary from simple queries, such as retrieving specific account information, or checking the state of the network, to sending transactions that modify state of the blockchain.</p> <p>Example</p> <p>Request of the getBlockHeight method:</p> <pre><code>curl https://api.mainnet-beta.solana.com -X POST -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"getBlockHeight\",\"params\":[]}'\n</code></pre> <p>Response of the getBlockHeight method:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"result\":269624245,\"id\":1}\n</code></pre> <p>Important</p> <p>The ability to send transactions is crucial because is the only way we can alter data on the blockchain. All write operations, including account creation or transfer of tokens are done through transactions.</p> <p>Info</p> <p>While users can interact with the blockchain through RPCs, it is not required. There are several libraries that provide convenient interfaces for languages such as JavaScript, Rust and Python.</p> Solana CLI <p>Typically, you will not be interacting with the network through raw RPC requests. Instead, you will often use a wrapper around them such as the interfaces mentioned above. Solana's Command-Line Interface (CLI) is a powerful tool that provides a more user-friendly experience for interacting with the blockchain.</p> <p>Example</p> <p>Solana CLI allows you to:</p> <ul> <li> <p>Generate a keypair <pre><code>solana-keygen new\n</code></pre></p> </li> <li> <p>View your public key <pre><code>solana-keygen pubkey\n</code></pre></p> </li> <li> <p>Check account balance <pre><code>solana balance &lt;account-address&gt;\n</code></pre></p> </li> <li> <p>Airdrop SOL (available on Devnet and Testnet) <pre><code>solana airdrop 1 &lt;account-address&gt;\n</code></pre></p> </li> </ul> <p>For more detailed information, checkout the documentation.</p>"},{"location":"handbook/chapter3/program-derived-address/","title":"Program Derived Address","text":"<p>Programs can issue instructions that include accounts that were not signed in the original transaction by using Program Derived Addresses (PDAs). These accounts are referred to as PDA accounts. PDAs allow for programmatically generated addresses to be used without needing a private key when invoking instructions of other programs.</p> <p>PDA is an address deterministically derived from the program ID and supplied seeds (keywords). However, the resulting address is bumped off the Ed25519 curve with a so-called bump seeds. This ensures that no private key exists for the PDA.</p> PDA Generation <p>When generating a PDA there is approximately 50% chance that the address will fall on the elliptic curve, meaning it has a corresponding private key. To avoid this, system uses bump seeds, an 8-bit number, to \"bump\" the address off the curve.</p> <p></p> <p>Insight</p> <p>To find a suitable bump seed, the program iterates through possible values from 255 down to 0. The first bump that works is known as the canonical bump.</p> <p>Warning</p> <p>Other bump seeds beyond the canonical bump may also result in a valid PDA. However, for security reasons, it is recommended to only use the canonical bump.</p> <p>When a program tries to invoke a CPI with PDA, the runtime takes the supplied keywords and bump seeds, uses the caller\u2019s program ID, and repeats the process. If the resulting PDA matches, the account is considered to be signed.</p>"},{"location":"handbook/chapter3/runtime-policy/","title":"Runtime Policy","text":"<p>Runtime policy is a set of rules enforced by the runtime to ensure security of the system:</p> <ol> <li> <p>Account Modification</p> <p>The contents of an account can only be modified by the program that owns the account. When an account is assigned to a program, its data is initialized to zero.</p> </li> <li> <p>Conservation of Balances</p> <p>The sum of balances across all accounts must not change before and after transaction execution.</p> </li> <li> <p>Read-Only Account Balances</p> <p>The balances of all read-only accounts cannot be changed by any program during transaction execution.</p> </li> <li> <p>Atomic Transaction Execution</p> <p>All instructions are executed atomically. If any instruction fails, the entire transaction fails.</p> </li> </ol> Compute Budget <p>Each transaction is allocated a compute budget to prevent abuse of node resources that could potentially lead to network failures or denial of service. When the program consumes its entire compute budget or exceeds certain bounds, the runtime halts the currently running instructions and returns an error.</p>"},{"location":"handbook/chapter3/transaction-anatomy/","title":"Transaction Anatomy","text":"Key Elements Important <p>Signature A 64 bytes long digital signature in the ed25519 format that verifies the authenticity and integrity of a transaction.</p> <p>Account A record in the Solana ledger that serves as a storage space for user data or an executable program.</p> <p>Compact Array An array-like data structure that starts with a 16-bit encoded array length, followed by the array elements.</p> <p>Blockhash A unique hash that identifies a block produced as a part of the Proof of History algorithm.</p> <p>Program ID The public key of an account that stores a compiled program on the blockchain.</p> <p>Instruction A command that specifies the Program ID to be executed, the accounts involved, and additional data that the program can use to determine the action to be performed.</p> Transaction Anatomy <p>Solana transactions consist of two major parts in the following order:</p> <ul> <li>A compact array of signatures.</li> <li>A message that contains a compact array of account addresses, a recent blockhash and a compact array of instructions.</li> </ul> <p></p> Signatures <p>For each signature in the compact array, the Solana verifies two conditions:</p> <ul> <li>The number of signatures must match the first 8 bits of the message header.</li> <li>Each signature is validated against the corresponding public key at the same index in the account addresses array.</li> </ul> Message Layout <p></p> <p>1. Header</p> <ul> <li>Number of required signatures in the transaction (8 bits).</li> <li>Number of read-only accounts requiring signatures (8 bits).</li> <li>Number of read-only accounts not-requiring signatures (8 bits).</li> </ul> <p>2. Accounts</p> <ul> <li>Addresses that require signatures with read-write access.</li> <li>Addresses that require signatures with read-only access.</li> <li>Addresses that do not require signatures with read-write access.</li> <li>Addresses that do not require signatures with read-only access.</li> </ul> <p>3. Recent blockhash</p> <ul> <li> <p>Ensures transaction lifetime</p> <p>Transaction is deemed invalid if the blockhash is older than 150 blocks (approximately 1 minute).</p> </li> <li> <p>Prevents transaction replay</p> <p>By tying each transaction to a unique recent blockhash, Solana ensures that identical transactions cannot be processed more than once.</p> </li> </ul> <p>4. Instructions with the following anatomy:</p> <ul> <li>Program ID index.</li> <li>Compact-array of account address indices.</li> <li>Compact-array of opaque 8-bit data (what operations to perform and any additional data).</li> </ul> <p></p>"},{"location":"handbook/chapter3/transaction-lifecycle/","title":"Transaction Lifecycle","text":"<p>The following steps can be thought of as an overview of what happens when an app or any user interacts with the Solana network by sending a transaction.</p> <ol> <li> <p>The user or app submits a transaction with one or more instructions to a node that accepts RPC requests.</p> </li> <li> <p>The transaction is then forwarded, according to the leader schedule, to the next leader.</p> </li> <li> <p>The leader validates the transaction, processes it, and includes it in a new block. This block is then broadcasted to all other validators who also validate and process the transaction.</p> </li> <li> <p>During the transaction processing, instructions are executed by the previously deployed programs, and relevant accounts are modified accordingly.</p> </li> </ol> <p>Important</p> <p>Everything happens in an isolated virtual machine. Instructions are executed sequentially and atomically, which means that either all instructions in the transaction complete successfully or none of the changes are applied.</p>"},{"location":"handbook/chapter4/","title":"Solana Program Library","text":"<p>The Solana Program Library (SPL) is a collection of on-chain programs. These programs facilitate tasks like creation and management of tokens and more.</p> <p></p> <ul> <li> <p> Token Program</p> <p>Solana's core program for creating and managing tokens.</p> <p>Token Program</p> </li> <li> <p> Mint Account</p> <p>Represents a specific type of token and stores global metadata.</p> <p>Mint Account</p> </li> <li> <p> Token Account</p> <p>Tracks the ownership and balance of tokens.</p> <p>Token Account</p> </li> <li> <p> Token-2022</p> <p>An updated token standard with additional features.</p> <p>Token-2022</p> </li> <li> <p> Account Compression</p> <p>Enables data compression, lowering costs for NFTs and other tokenized assets.</p> <p>Account Compression</p> </li> </ul>"},{"location":"handbook/chapter4/account-compression-program/","title":"Account Compression","text":"Merkle Tree <p>A Merkle tree is a data structure that organizes data into a tree-like form.</p> <ul> <li>Each leaf node inside this tree represents a hash of some data.</li> <li>Each non-leaf node represents a hash of its child nodes.</li> </ul> <p>The root is a compact representation of all data stored in the tree. Merkle trees allows us to easily verify integrity of the data without having to store all of it on-chain.</p> Tree Terminology <p>Tree is a term from graph theory and it refers to a type of a graph.</p> <ul> <li>Root node is the top-most node of a tree, which does not have a parent. (example node A)</li> <li>Non-leaf node is a node that does have children in the tree. (example nodes A and B)</li> <li>Leaf node is a node that does not have any children in the tree. (example nodes C, D and E)</li> </ul> Example Tree Graph<pre><code>           A is the root of the tree   A\n                                      / \\\n    B is a parent of nodes D and E   B   C\n                                    / \\\n          D is a child of node B   D   E\n</code></pre> Account Compression Program <p>Minting a single NFT may be relatively inexpensive, however, the cost of storing the asset's data on-chain can quickly become uneconomical as the quantity increases.</p> <p>The Account Compression program is an on-chain system designed to address the rising concern of storage costs on Solana.</p> <p>The solution lies in storing a compressed hash of the asset data on-chain, while the actual data is stored off-chain in a database. The data is split into pieces, a Merkle tree is built and only the Merkle root is stored on-chain.</p> <p>Info</p> <p>The account compression program uses a special type of Merkle tree called a concurrent Merkle tree. Concurrent Merkle trees allow simulataneous data changes to occur while still maintaining the integrity of the tree.</p> Zero-Knowledge Compression <p>Important</p> <p>Zero-knowledge (ZK) proofs allow one party to prove to another party that some statement is true without revealing any information about the statement itself.</p> <p>ZK proofs can be used to further reduce the amount of data that needs to be stored on a blockchain. With ZK proofs, we can verify that certain calculations or balances are correct without needing to store or reveal the underlying data.</p>"},{"location":"handbook/chapter4/mint-account/","title":"Mint Account","text":"<p>The mint account represents a specific type of token by storing the token's global metadata. The mint account contains these data fields:</p> <ul> <li>Supply: Total supply of the token.</li> <li>Decimals: The number of decimal places the token can be divided into.</li> <li>Mint authority: The account authorized to mint new tokens. (Optional)</li> <li>Freeze authority: The account authorized to freeze token transfers. (Optional)</li> </ul> <p>Tip</p> <p>Check out the mint accounts for USDC and wBTC.</p>"},{"location":"handbook/chapter4/token-2022/","title":"Token-2022","text":"<p>The Token-2022 program extends the functionality provided by the Token program. This means that the Token-2022 program is not only backward compatible but also includes all the functions of the original Token program, as well as additional functionality often referred to as token extensions.</p> <p>Info</p> <p>One associated token account program still creates token accounts for both Token and Token-2022.</p> <p>Tip</p> <p>To see the source code, check out Solana Program Library Token-2022 program.</p> Benefits <ul> <li> <p>Flexibility</p> <p>Some token extension are incompatible, however, you can create a variety of custom combinations that fit your needs.</p> </li> <li> <p>Reduced risk</p> <p>Using audited and well-tested extensions helps protect protocols and funds.</p> </li> <li> <p>Reduced testing costs</p> <p>Extensions are added by specifying the extensions in code, this reduces number of errors and saves time on testing.</p> </li> <li> <p>Reduced development time</p> <p>Extensions are uniform and reusable, which significantly speeds up development.</p> </li> </ul> Extensions <p>There are two types of extensions:</p> <ul> <li>Mint Extensions</li> <li>Token Account Extensions</li> </ul> <p>Note</p> <ul> <li>Mint extensions are added on top of the original Solana Token program and extend the capabilities of tokens.</li> <li>Token account extensions are added on top of Solana accounts and add account-related features.</li> </ul> <p>Mint extensions:</p> <ul> <li>Confidential transfers: Confidential transactions that do not reveal the amount transferred.</li> <li>Transfer fees: Collection of fees on each transfer. The fees are then sent to a specified account.</li> <li>Mint close authority: Enables mint owners to close their accounts and reclaim the lamports.</li> <li>Transfer hook: Calls specific programs when a token transfer occurs.</li> <li>Interest-bearing tokens: Set an interest rate on a token. The interest can be tracked and displayed.</li> <li>Non-transferable tokens:  Restrict token transfers between users.</li> <li>Permanent delegate: Permanently assign a delegate that has the authority to manage token accounts of a given mint.</li> <li>Metadata pointer: Allows token creators to link an external address that contains the official metadata of the token.</li> <li>Metadata:  Allows integration of metadata into tokens through custom fields.</li> </ul> <p>Token account extensions include:</p> <ul> <li>Memo required on transfer: Requires an attached memo as a message during each token transfer.</li> <li>Immutable owner: Makes it impossible to reassign ownership of an account.</li> <li>Default account state: Freezes all new token accounts so that users must interact with the project in some way to unfreeze the accounts/tokens.</li> <li>CPI guard: Restricts how other programs can interact with your token by prohibiting certain actions inside cross-program invocations.</li> </ul> <p>Note</p> <p>You can find a list of Token-2022 extensions in the documentation.</p>"},{"location":"handbook/chapter4/token-account/","title":"Token Account","text":"<p>A token account on Solana is a general term for any account that holds tokens. Token accounts are created by the Token program and store different types of tokens. Every account has a unique mint address, and a token account holds tokens of a specific mint account.</p> <p></p> <p>The Token program is the owner of a token account. However, another account can be specified as the authority with the ability to transfer tokens. This means that while the Token program manages the structure of the token account, another account controls the movement of tokens.</p> Token Account Structure <p>The structure of a token account resembles that of a regular account. It holds lamports, has an executable flag (set to false), owner (Token Program) and stores additional data.</p> <p>These data fields provide enhanced account management features. For example, you can specify a delegate account, which can then spend tokens up to a delegated_amount.</p> <p>Main fields:</p> <ul> <li>Mint: The type of token the account holds.</li> <li>Owner: The account with authority to transfer the tokens.</li> <li>Amount: The number of tokens the account holds.</li> </ul> <p>Additional fields:</p> <ul> <li>Delegate: Delegate authority having possession over delegate amount. (Optional)</li> <li>IsNative: Specifies whether the token account holds wrapped SOL. (Optional)</li> <li>Delegate amount: Amount authorized by the delegate authority.</li> <li>Close authority: Authority able to close the token account. (Optional)</li> </ul> Associated Token Account <p>An Associated Token Account (ATA) is a token account, but its address has a special property.</p> <p>Important</p> <p>An Associated Token Account address is derived (as a PDA) from its owner's wallet address and the address of the mint.</p> <p>This means that user has a different ATA for every wallet and token mint combination. This is very convenient because programs can easily find and interact with the correct account without needing the user to provide the address.</p> <p>Info</p> <p>A user can receive tokens even if they do not yet have a token account for that mint. The sender is able to fund the creation of the receiver's ATA, enabling things like airdrop campaigns.</p> <p>Associated Token Account program facilitates the creation and management of ATAs.</p>"},{"location":"handbook/chapter4/token-program/","title":"Token Program","text":"Fungible and Non-Fungible Tokens <p>Fungible Tokens: These tokens are interchangeable with one another. They are indistinguishable and hold the same value.</p> <p>Non-Fungible Tokens (NFTs): Each NFT is a special digital asset that holds a unique information or value. NFTs can represent ownership of a specific digital or physical item, such as digital art or real estate.</p> Token Program <p>Token program defines a common implementation for fungible and non-fungible tokens. All tokens on Solana are created using the SPL Token program.</p> <p>Tip</p> <p>To see the source code, check out Solana Program Library Token program.</p> <p>Info</p> <p>Solana's SPL tokens are similar to Ethereum's ERC-20 or ERC-721 standards. However, Solana does not require you to deploy a new contract for each token you create. Instead, you simply send instructions to the Token program, which will create and mint tokens on your behalf.</p> <p></p> Creating Tokens <p>A token can be created by initializing a new mint account. The mint account is used to create and hold info about new tokens, which are then stored in token accounts. Once a mint account is initialized, the mint_authority can create (mint) new tokens using the MintTo instruction.</p> <p>Important</p> <p>As long as mint account contains a valid mint_authority, it is considered to have a non-fixed supply, and the mint_authority can create new tokens with the MintTo instruction at any time.</p> Transferring Tokens <p>Balances can be transferred between accounts using the Transfer instruction, with the source account owner required as a signer when the accounts differ.</p> Burning Tokens <p>The Burn instruction decreases an account's token balance without transferring to another account. The burnt tokens are permanently removed from the circulation, and this action can be verified on chain.</p> Freezing Accounts <p>The mint account may include a freeze_authority, allowing it to invoke FreezeAccount instruction that will make account unusable. Frozen accounts can be reactivated using the ThawAccount instruction and freeze_authority can be changed using the SetAuthority instruction.</p> Wrapping SOL <p>SOL can be wrapped and used like a Token program token when interacting with programs that use the Token program's interface. Accounts that hold wrapped SOL are associated with Native Mint. Wrapped SOL token accounts have unique behaviors, which you can learn more about here.</p>"}]}