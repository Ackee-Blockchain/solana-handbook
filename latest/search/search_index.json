{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Solana Handbook","text":""},{"location":"#learn-the-fundamentals-of-solana","title":"Learn the fundamentals of Solana!","text":"<p>This handbook was written for developers, auditors and anyone interested in how Solana works. Starting with the basics and terminology, it gradually introduces more advanced topics, providing a comprehensive overview without going too in-depth.</p> <p>Good luck, and enjoy the journey!</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li> <p> Solana Basics</p> <p>Learn the basics of Solana blockchain.</p> <p>Solana Basics</p> </li> <li> <p> Core Concepts</p> <p>Solana can be described by the eight core concepts that make it unique and fast.</p> <p>Core Concepts</p> </li> <li> <p> Programming Model</p> <p>Explore Solana's programming model.</p> <p>Programming Model</p> </li> <li> <p> Solana Program Library</p> <p>Collection of programs that simplify tasks like token creation, management, and more.</p> <p>Solana Program Library</p> </li> <li> <p> Appendices</p> <p>Additional information about Solana's ecosystem.</p> <p>Appendices</p> </li> </ul>"},{"location":"#about-authors","title":"About Authors","text":"<p>This handbook was created with love by Solana Auditors and Developers of Ackee.</p> <p>Ackee is a blockchain security company founded in 2021, specializing in audits and other security assessments.</p> <p>To strengthen the blockchain ecosystem, the team develops open-source frameworks Wake and Trident. Additionally, they share their knowledge through free certification courses:</p> <ul> <li>School of Solana</li> <li>Solana Auditors Bootcamp</li> <li>School of Solidity</li> </ul>"},{"location":"handbook/appendices/","title":"todo appendices landing page","text":""},{"location":"handbook/appendices/authors/","title":"About Authors","text":"<p>This handbook was created with love by Solana Auditors and Developers of Ackee.</p> <p>Ackee is a blockchain security company founded in 2021, specializing in audits and other security assessments. Its team of experts performs Ethereum and Solana audits and develops open-source security frameworks Wake and Trident.</p> <p>By running free certification courses: the School of Solana and the School of Solidity, Ackee contributes to a stronger blockchain ecosystem by sharing knowledge.</p>"},{"location":"handbook/appendices/appendixA/popular-projects/","title":"Popular Projects","text":"<p>Solana's blockchain has become a fertile ground for innovation, attracting numerous high-profile projects due to its speedy, reliable, and scalable solutions for blockchain applications and technologies. Below, we've curated a list of some of the best-known names in their respective domains, but don't be misled; this is just the tip of the iceberg. There are many more applications and projects thriving on the Solana platform, contributing to a vibrant and continually expanding ecosystem.</p>"},{"location":"handbook/appendices/appendixA/popular-projects/#derivatives","title":"Derivatives","text":"<p>Derivatives are products including options, futures, collateralized loans, and prediction markets, where an arrangement or instrument has a value derived from the underlying asset.</p> <ul> <li>HXRO</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#decentralized-exchanges-on-solana","title":"Decentralized exchanges on Solana","text":"<p>Decentralized exchanges (DEXs) are a pivotal innovation in the world of cryptocurrency, allowing users to trade assets directly with one another without the need for an intermediary or centralized entity. Unlike traditional exchanges, where the exchange controls the user's funds, DEXs operate on smart contracts that handle the trading process. This design enhances security and privacy, as users retain control over their private keys. While offering benefits like reduced risk of hacking and censorship resistance, DEXs may face challenges such as lower liquidity and higher fees compared to centralized counterparts. Nevertheless, they represent a significant step towards a more decentralized and transparent financial ecosystem.</p> <ul> <li>Orca</li> <li>Raydium</li> <li>Saber</li> <li>Jupiter Aggregator</li> <li>Mango Markets</li> <li>Drift Protocol</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#solana-liquid-staking","title":"Solana Liquid Staking","text":"<p>Liquid staking is a financial innovation within the crypto space that allows users to stake their assets while still having access to liquidity. Essentially, it lets participants earn staking rewards without locking up their tokens, by issuing synthetic or derivative tokens in return. This flexibility fosters greater participation and efficiency in proof-of-stake networks.</p> <ul> <li>Lido</li> <li>Marinade Finance</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#decentralized-lending-on-solana","title":"Decentralized Lending on Solana","text":"<p>Decentralized lending refers to peer-to-peer lending practices conducted on blockchain networks. By using smart contracts, it eliminates traditional financial intermediaries, allowing users to borrow or lend funds directly to one another. This offers more accessible and potentially lower-cost lending options, promoting financial inclusion and greater control over personal finance.</p> <ul> <li>Solend</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#marketplaces","title":"Marketplaces","text":"<p>There are multiple NFT marketplaces to trade NFTs (see Chapter 7 for more about NFTs), which are theoretically supposed to represent a certificate of ownership of something. The trend of NFTs is closely coupled with an old-new concept of Metaverse, an artificial world where people could meet as virtual avatars and show off their collectible NFTs. NFTs may find useful applications in the future for representing real-world items, such as concert tickets, but it remains to be seen if they offer any real advantage in practice or if the technology continues to be used largely for speculation.</p> <ul> <li>MagicEden</li> <li>Tensor</li> <li>Solanart</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#analytics","title":"Analytics","text":"<p>Analytics tools on blockchain provide insights into transactions, network health, and user behavior. They enable transparency, traceability, and data-driven decision-making, enhancing efficiency and trust within the decentralized ecosystem.</p> <ul> <li>DefiLlama</li> <li>Dune Analytics</li> <li>Nansen</li> <li>VybeNetwork</li> <li>Step Finance</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#tooling","title":"Tooling","text":"<p>Tools that enhance the safety of smart contracts facilitate thorough testing and validation, detecting vulnerabilities and errors. They improve the overall workflow of developing decentralized applications, ensuring robustness and security. Additionally, they enhance the usability of existing smart contracts, making them more accessible and efficient for users.</p> <ul> <li>Solana Anchor Framework</li> <li>Trident Testing and Fuzzing Framework</li> <li>Solang</li> <li>Metaplex</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#gaming","title":"Gaming","text":"<p>First games built on Solana are starting to appear, using the blockchain as a back end (see Appendix C for more about gaming) \u2013 this type of development paradigm is referred to as Web3. In general, any application using blockchain as a layer of data and business logic can be considered Web3. When a user visits such a website, they can usually connect their wallet with the website and interact with it by sending transactions that could, e.g., post a message on a Web3 social media platform or place an order on a decentralized exchange.</p> <ul> <li>Star Atlas</li> <li>xNFTs with BackPack</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#real-world-projects","title":"Real World Projects","text":"<p>The remarkable benefits of the Solana Blockchain make it a magnet for projects affiliated with real-world applications.</p> <ul> <li>Helium</li> <li>Render Network</li> <li>HiveMapper</li> </ul>"},{"location":"handbook/appendices/appendixA/popular-projects/#bridges","title":"Bridges","text":"<p>Crosschain bridges enable the transfer of assets and information between different blockchain networks. They enhance interoperability, allowing seamless transactions across various platforms, thus expanding possibilities within the decentralized ecosystem.</p> <ul> <li>Wormhole</li> <li>DeBridge Finance</li> </ul>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/","title":"Solana Mobile Phone","text":"<p>As you may have observed, Solana has recently introduced its own mobile phone. In this section, We will outline essential details regarding the Solana Mobile Stack.</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#whats-in-the-solana-mobile-stack","title":"What's in the Solana Mobile Stack?","text":"<p>The Solana Mobile Stack (SMS) is a collection of key technologies for building mobile applications that can interact with the Solana blockchain.</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#mobile-wallet-adapter","title":"Mobile Wallet Adapter\u200b","text":"<p>Mobile Wallet Adapter (MWA) is a protocol specification for connecting mobile dApps to mobile Wallet Apps, enabling communication for Solana transaction and message signing.</p> <p>dApps that implement MWA are able to connect to any compatible MWA Wallet App and request authorization, signing, and sending for transactions/messages.</p> <p>Why this is important: Developers no longer need to build in support for each individual wallet, and instead can just integrate once and use a single unified API to be compatible with every compliant Solana wallet!</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#using-the-sdk","title":"Using the SDK","text":"<p>Solana Mobile maintains an official Mobile Wallet Adapter SDK that implements the protocol, originally written as a Android Kotlin/Java library.</p> <p>The SDK is also ported other frameworks and is available for:</p> <ul> <li>React Native</li> <li>Flutter</li> <li>Unity</li> <li>Unreal Engine</li> </ul>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#seed-vault","title":"Seed Vault","text":"<p>The Seed Vault is a system service providing secure key custody to Wallet apps. By integrating with secure execution environments available on mobile devices (such as secure operating modes of the processor and/or secure auxiliary coprocessors), Seed Vault helps to keep your secrets safe, by moving them to the highest privileged environment available on the device. Your keys, seeds, and secrets never leave the secure execution environment, while UI components built into Android handle interaction with the user to provide a secure transaction signing experience to users.</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#solana-dapp-store","title":"Solana dApp Store","text":"<p>The Solana dApp Store is an alternate app distribution system, well suited to distributing apps developed by the Solana ecosystem. It will provide a distribution channel for apps that want to establish direct relationships with their customers, without other app stores\u2019 rules restricting the relationship or seeking a large revenue share. The goal of the Solana dApp Store is to empower the Solana community to eventually play a key role in managing the contents of this app store.</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#solana-pay-for-android","title":"Solana Pay for Android","text":"<p>The Solana Pay protocol was developed independently of the Solana Mobile Stack, but combining payments with a mobile device is a natural fit for Solana Pay. The Solana blockchain confirms transactions in less than a second and costs on average $0.0005, providing users a seamless experience with no intermediaries. Businesses and developers can use Solana Pay to accept payments in SOL or any SPL token without intermediaries. It offers frictionless and portable integration options like payment links, pay now buttons or QR codes on your app, dApp, website, blog, and so much more.</p>"},{"location":"handbook/appendices/appendixA/solana-mobile-phone/#ecommerce-platform-integrations","title":"eCommerce Platform Integrations","text":"<p>Solana Labs has started a reference implementation for Shopify which you can see here to get a sense of how this might work.</p> <p>Here are some of the top eCommerce platforms that they're looking to integrate to:</p> <ul> <li>WooCommerce</li> <li>Magento</li> <li>BigCommerce</li> <li>Wix</li> <li>Squarespace</li> </ul>"},{"location":"handbook/appendices/appendixA/wallets/","title":"Wallets","text":"<p>The Solana ecosystem consists of various user-facing products like wallets and tools that allow anyone to easily create their token or a Non-Fungible Token (NFT) and use the network without much hassle.</p> <p>There are various web wallets, Android and iOS app wallets for smartphones, browser extensions, and also official CLI tools. They differ in capabilities and out-of-the-box support for various Solana projects or being developer-oriented.</p> <p>The major ecosystem wallet providers include:</p> <ul> <li>Phantom (iOS/Android apps and all major browser extensions)</li> <li>Solflare (Web wallet, iOS/Android apps, and chrome-only extension)</li> <li>Sollet (Developer-oriented web wallet and chrome-only extension)</li> <li>Backpack (Web wallet, iOS/Android coming soon)</li> </ul> <p>(At the time of writing, summer 2023)The only supported hardware wallets to safely interact and store keys to access cryptocurrencies and other assets are now Ledger and Trezor products:</p> <ul> <li>Trezor Safe 3</li> <li>Trezor Model T</li> <li>Ledger Nano S</li> <li>Ledger Nano X</li> </ul>"},{"location":"handbook/appendices/appendixB/candy-machine/","title":"Candy Machine","text":"<p>The Metaplex Protocol Candy Machine is the leading minting and distribution program for fair NFT collection launches on Solana. Much like its name suggests, you can think of a Candy Machine as a temporary structure which is first loaded by creators and then unloaded by buyers. It allows creators to bring their digital assets on-chain in a secure and customisable way.</p> <p>The name refers to the vending machines that dispense candy for coins via a mechanical crank. In this case the candy are NFTs and the payment is SOL or a SPL token.</p> <p>By September 2022, 78% of all NFTs in Solana were minted through Metaplex\u2019s Candy Machine. This includes most of the well known NFT projects in the Solana ecosystem.</p> <p>Here are some of the features it offers.</p> <ul> <li>Accept payments in SOL, NFTs or any Solana token.</li> <li>Restrict your launch via start/end dates, mint limits, third party signers, etc.</li> <li>Protect your launch against bots via configurable bot taxes and gatekeepers like Captchas.</li> <li>Restrict minting to specific NFT/Token holders or to a curated list of wallets.</li> <li>Create multiple minting groups with different sets of rules.</li> <li>Reveal your NFTs after the launch whilst allowing your users to verify that information.</li> <li>And so much more!</li> </ul> <p></p> <p>For illustrative purposes, we've included the Figure above. However, we won't delve deep into the intricate logic behind the Candy Machine Program, as such a detailed exploration would be too exhaustive for this guide. Our primary aim is to familiarize you with Solana and its burgeoning ecosystem. Those seeking a deeper understanding can delve further into this documentation.</p>"},{"location":"handbook/appendices/appendixB/compression/","title":"Compression","text":"<p>Compressed NFTs use State Compression and merkle trees to drastically reduce the storage cost for NFTs (Figure 1.16). Instead of storing an NFT's metadata in a typical Solana account, compressed NFTs store the metadata within the ledger. This allows compressed NFTs to still inherit the security and speed of the Solana blockchain, while at the same time reducing the overall storage costs.</p> <p>Even though the on-chain data storage mechanism is different than their uncompressed counterparts, compressed NFTs still follow the exact same Metadata schema/structure. Allowing you to define your Collection and NFT in an identical way.</p> <p></p> <p>This chart is based on a snapshot taken on April 5, 2023 and based on a price of SOL at $21.14, MATIC at $1.14, and ETH at $1,909.45.</p> <p>State compression is already being used by teams across the Solana ecosystem to power large, user-friendly experiences</p> <ul> <li> <p>Dialect</p> <ul> <li>a blockchain-based messaging service, uses state compression for compressed NFTs to cover the minting cost of NFT stickers to thousands of users.</li> </ul> </li> <li> <p>Crossmint</p> <ul> <li>an NFT and API tooling company, is using state compression to create integrations that power deeper customer loyalty for companies around the world.</li> </ul> </li> </ul> <p>And that\u2019s just the beginning \u2014 projects like user-owned wireless network Helium, NFT distributor DRiP, and on-chain publisher Wordcel, are using state compression to bring their scalable, user-first experiences to Solana.</p> <p>Although state compression can be used to store any sort of data on-chain, the first use of this innovative technology is compressed NFTs. Compressed NFTs are just like regular NFTs, only drastically cheaper \u2014 minting 100 million compressed NFTs costs about \u25ce50 to store on-chain, compared to \u25ce1.2mm for their uncompressed counterpart. In fact, because every incremental compressed NFT is solely a modification of an existing tree, the cost of an NFT on Solana is now as little as the cost of a single transaction (\u25ce0.000005)!</p>"},{"location":"handbook/appendices/appendixB/executable-nft/","title":"Executable NFT","text":"<p>Executable NFTs, available in the open beta of new open source wallet Backpack, represent an entirely new way to build applications that are safer, better to use, and in line with the decentralized values blockchain is built on. By combining executable websites and applications that can run locally on a user\u2019s computer with a crypto wallet, xNFTs in Backpack show a promising new type of hybrid web3 application \u2013 not quite an application, not quite a website.</p> <p>xNFTs take a radically practical approach to solving two of web3\u2019s main problems today, decentralization and distribution, with profound implications. While smart contracts run on globally distributed and decentralized networks like Solana, nearly everyone who interacts with smart contracts does so through a website. These centralized, web2 interfaces, and the services that run them, often require the project to register a company, open a bank account, obtain a business debit or credit card, register a domain, and a whole host of other actions just to provide users with a graphical user interface. Each step in that process takes time, money, and adds a potential source of risk for the project\u2019s creators.</p> <p>xNFT Collections unlock whole new avenues for program distribution. A game developer can mint their entire game as limited-edition xNFTs. A DeFi protocol can distribute early access to a new front-end based on wallet addresses. A two-factor code can be generated as an NFT, and automatically cycle through. An artist can create beautiful immersive 3d experiences that can\u2019t be copied, and run directly in the wallet. The possibilities are almost limitless.</p> <p>Because they are, at their core, NFTs, xNFTs can bring a new level of interactivity to traditional collections. The first xNFT Collection, Mad Lads, showcases the power of an executable profile picture collection \u2014 the pictures themselves act as a chatroom for users which is rendered entirely within the NFT.</p> <p>xNFTs are not some new smart contracting language, a scaling solution, or a core technology that will take years to deploy. They exist today. This is just one of the many ecosystem-wide innovations that have supercharged the Solana protocol and greater community.</p> <p></p>"},{"location":"handbook/appendices/appendixB/metadata-off-chain/","title":"Storing Metadata Off-chain","text":"<p>One important attribute of the Metadata Account is the URI attribute that points to a JSON file off-chain. This is used to safely provide additional data whilst not being constrained by the fees involved in storing on-chain data. That JSON file follows a certain standard that anyone can use to find useful information on tokens.</p> <p>Note that, this JSON file can be stored using a permanent storage solution such as Arweave to ensure it cannot be updated. Additionally, one can use the Is Mutable attribute of the Metadata Account to make it immutable and, therefore, forbid the URI attribute \u2014 and other attributes such as Name and Creators \u2014 to ever be changed. Using this combination, we can guarantee the immutability of the off-chain JSON file.</p>"},{"location":"handbook/appendices/appendixB/metadata-off-chain/#arweave","title":"Arweave","text":"<p>Arweave is a decentralized, trust-minimized, censorship-resistant data storage network designed to retain data permanently, making it a great fit for NFTs. To cover the cost of storing your media forever, storage and mining fees are paid at the time of upload and distributed to storage providers participating in the network.</p> <p>Arweave storage fees:</p> <ul> <li>Storage fees are based on the total size of the files you upload to the network during NFT creation. Each NFT consists of three files         - The asset itself (image, video, audio, etc)         - The accompanying metadata file (attributes etc.)         - A generated manifest which creates a logical grouping or relationship between your files</li> <li>The cumulative size of these files (in bytes) is submitted to the Arweave storage cost estimation service which returns the real time estimated fee for storage, priced in winstons. We then convert the winstons to SOL for payment.</li> </ul>"},{"location":"handbook/appendices/appendixB/metadata-off-chain/#other-possibilities","title":"Other possibilities","text":"<ul> <li>AWS S3</li> <li>IPFS</li> <li>NFT.Storage</li> <li>Shadow Drive</li> </ul> <p>For further details, refer to the documentation.</p>"},{"location":"handbook/appendices/appendixB/nfts/","title":"Appendix B - NFTs","text":"<p>The phenomenal rise of non-fungible tokens and innovative developments in the NFT landscape have encouraged many people to mint their own NFTs. Solana blockchain has emerged as a popular solution for minting NFTs with its Metaplex platform. The Metaplex is a Solana-based protocol that helps in creating NFTs and auctions. The Candy Machine Metaplex protocol serves as the primary foundation for minting and distribution of NFT collections.</p>"},{"location":"handbook/appendices/appendixB/token-metadata-program/","title":"Token Metadata Program","text":"<p>The Token Metadata program is one of the most important programs when dealing with NFTs on the Solana blockchain. Its main goal is to attach (Figure 1.11) additional data to Fungible or Non-Fungible Tokens on Solana.</p> <p>It achieves this using Program Derived Addresses (PDAs) that are derived from the address of Mint Accounts. You should be familiar with Solana\u2019s Token program from SPL (for reminder, Figure 1.10), Mint Accounts are responsible for storing the global information of a Token and Token Accounts store the relationship between a wallet and a Mint Account.</p> <p></p> <p>Whilst Mint Accounts contain a few data attributes such as its current supply, it doesn't offer the ability to inject standardized data that can be understood by apps and marketplaces. This is why the Token Metadata program offers a Metadata Account that attaches itself to a Mint Account via a PDA.</p> <p></p>"},{"location":"handbook/appendices/appendixB/token-standard/","title":"Is this all ? \u201cNo, Token Standard\u201d","text":"<p>As token usage has evolved on Solana, it has become clear that there are more types of tokens than simply \"fungible\" and \"non-fungible\" tokens.</p> <p>An example is something the community is calling a \"semi-fungible token\", an SPL token with a supply greater than 1 but which has typical NFT attributes such as an image and an attributes array in the JSON metadata.</p> <p>The consensus seems to be that these should be stored in wallets in the same view as standard NFTs, or in their own view but separate from \"standard\" fungible SPL tokens. These tokens are becoming popular in gaming contexts to support fungible items such as a kind of sword or a piece of wood, etc. but which are in a different league from typical fungible SPL tokens such as USDC.</p> <p>The Token Standard field (in Metadata Account) can have the following values:</p> <ul> <li>NonFungible: A non-fungible token with a Master Edition.<ul> <li>Examples of these are Solana Monkey Business, Stylish Studs and Thugbirdz.</li> </ul> </li> <li>FungibleAsset: A token with metadata that can also have attributes, sometimes called Semi-Fungible.<ul> <li>An example of this kind of token is something the community has been calling \"semi-fungible tokens\" often used to represent a fungible but attribute-heavy in-game item such as a sword or a piece of wood.</li> </ul> </li> <li>Fungible: A token with simple metadata.<ul> <li>USDC, GBTC and RAY.</li> </ul> </li> <li>NonFungibleEdition: A non-fungible token with an Edition account (printed from a Master edition).<ul> <li>very similar to NonFungible (more here).</li> </ul> </li> <li>ProgrammableNonFungible: A special NonFungible token that is frozen at all times to enforce custom authorization rules.<ul> <li>This standard is similar to the Non-Fungible standard above, except that the underlying token account is kept frozen at all times to ensure nobody can transfer, lock or burn Programmable NFTs without going through the Token Metadata program. This enables creators to define custom authorization rules for their NFTs such as enforcing secondary sales royalties.</li> </ul> </li> </ul>"},{"location":"handbook/appendices/appendixB/token-standard/#programmable-non-fungible-tokens","title":"Programmable Non-Fungible-Tokens","text":"<p>Because the Token Metadata program builds on top of the Solana Token program, anyone can transfer tokens (fungible or not) without going through the Token Metadata program. In other words, Metadata Account contains field Seller Fee Basis Points, which holds information about secondary sales royalties. The problem is, if we want to transfer tokens (fungible or not), we don't use Metaplex (as its only purpose is to store additional data), however we use SPL for Token Transfer. Whilst there is Seller Fee Basis Points attribute on the Metadata account, it is purely indicative and anyone could create a marketplace that does not honor royalties \u2014 which is exactly what happened.</p> <p>Programmable NFTs were introduced to solve this problem. They are a new opt-in Token Standard that keeps the underlying token accounts frozen at all times. That way, nobody can transfer, lock or burn Programmable NFTs without going through the Token Metadata program.</p> <p>It is then up to the creators to define custom operation-specific authorization rules (Figure 1.14) that will be enforced by the Token Metadata program. These are defined in a special RuleSet account which is attached to the Metadata account. An example of such a RuleSet could be an allowlist of program addresses that honor royalties. RuleSets are part of a new Metaplex program called Token Auth Rules.</p> <p></p>"},{"location":"handbook/appendices/appendixB/what-is-metaplex/","title":"What is Metaplex?","text":"<p>Metaplex is a decentralized protocol built on the Solana blockchain designed to simplify the creation, sale, and use of NFTs. By offering a suite of development tools, smart contracts, and open standards, Metaplex enables NFT communities to issue, manage, and own digital assets on-chain.</p> <p>Metaplex continuously develops and maintains several programs and standards to enhance user experience and meet the evolving needs of its community.</p> <p>Currently, major projects are</p> <ul> <li>Token Metadata - the NFT standard for Solana</li> <li>Candy Machine v3\u2122 - a Profile Picture (PFP) focused tool that works like the gumball-style candy machines of old. Candy Machine V3 supports the minting of programmable NFTs.</li> <li>Auction House - a decentralized sales protocol for NFT marketplaces</li> <li>Creator Studio - No-code tools to create, sell, and manage NFTs on Solana.</li> <li>Fixed-Price Sale - A program that enables creators to build/distribute membership NFTs at a fixed-price that grants holders access to exclusive content and events. It supports the restriction of sales to specific collection holders.</li> <li>Compression - A program for creating and interacting with compressed Metaplex NFTs. Compressed NFTs are secured on-chain using Merkle trees.</li> </ul>"},{"location":"handbook/appendices/appendixB/what-nfts/","title":"What has this got to do with NFTs?","text":"<p>Well, NFTs are special tokens that are Non-Fungible. More precisely,</p> <p>NFTs on Solana are Mint Accounts with the following characteristics (Figure 1.12):</p> <ul> <li>It has a supply of 1, meaning only one token is in circulation.</li> <li>It has zero decimals, meaning there cannot be such a thing as 0.5 tokens.</li> <li>It has no mint authority, meaning no one can ever mint additional tokens.</li> </ul> <p></p> <p>Metaplex suite offers essential tools for NFT creation on Solana, including the NFT Metadata program itself, minting tools and marketplex, and auction toolkits.</p> <p>Outside of the essential tools, the toolkit also contains many other rather experimental tools like Fireball, Fuse, and Gumball that enable NFT creators to do many different things with their NFTs on Solana.</p>"},{"location":"handbook/appendices/appendixB/what-nfts/#master-edition","title":"Master Edition","text":"<p>Additionally, the Token Metadata program offers another account specifically for NFTs called the Master Edition Account (Figure 1.13). This account is also a PDA derived from the Mint Account.</p> <p>Before creating this account, the Token Metadata program will ensure the special characteristics of Non-Fungible Tokens listed above are met. Thus, the existence of the Master Edition account acts as proof of Non-Fungibility for that Mint Account. As shown in Figure 1.13, the Master Edition Account incorporates several fields that haven't been addressed yet. While these fields hold significance, they aren't pivotal for understanding the core principle. In essence, Metaplex offers the capability to create copy of NFTs, wherein the Master Edition, and likewise the Edition Account, functions as evidence of either replication or originality.</p> <p></p>"},{"location":"handbook/chapter1/","title":"Solana Introduction","text":"<p>Learn what Solana is and understand basic blockchain terminology, from blocks to smart contracts.</p> <p></p> <ul> <li> <p> Introduction</p> <p>A short introduction to Solana.</p> <p>Introduction</p> </li> <li> <p> Blockchain</p> <p>Learn what is a blockchain.</p> <p>Blockchain</p> </li> <li> <p> Transaction</p> <p>Learn what transactions are and how they relate to instructions.</p> <p>Transaction</p> </li> <li> <p> Infrastructure</p> <p>Explore essential components that run the network.</p> <p>Infrastructure</p> </li> <li> <p> Security</p> <p>See how Solana ensures network security and consensus integrity.</p> <p>Security</p> </li> <li> <p> Slots, Epochs and Leaders</p> <p>Learn about Solana's time structure and leader rotation.</p> <p>Slots, Epochs and Leaders</p> </li> <li> <p> Smart Contract</p> <p>A program deployed on a blockchain.</p> <p>Smart Contract</p> </li> <li> <p> Ecosystem</p> <p>Solana is not just a currency!</p> <p>Ecosystem</p> </li> </ul>"},{"location":"handbook/chapter1/blockchain/","title":"Blockchain","text":""},{"location":"handbook/chapter1/blockchain/#block","title":"Block","text":"<p>Block is a data structure that contains a header and a set of transactions. Header is comprised of three items \u2013 the hash of the previous block\u2019s header, metadata and a Merkle root. Metadata depends on the protocol. The Merkle root is a root of the well-known Merkle tree, which can be used to verify later that transactions in a block have not been tampered with.</p>"},{"location":"handbook/chapter1/blockchain/#blockchain","title":"Blockchain","text":"<p>A blockchain can be thought of as a series of blocks or an append-only data structure that resembles an ordered back-linked linked list, which uses hashes as pointers to previous blocks. This structure consists of blocks that form a chain, hence the term blockchain.</p> <p></p> <p>Important</p> <p>Header is used to maintain the blockchain's integrity. If any part of the header changes, the hash will change, breaking the link to subsequent blocks.</p>"},{"location":"handbook/chapter1/ecosystem/","title":"Ecosystem","text":""},{"location":"handbook/chapter1/ecosystem/#beyond-currency","title":"Beyond Currency","text":"<p>While many people associate Solana primarily with its native cryptocurrency SOL, it is important to understand that Solana is far more than just a digital currency. Solana is a high-performance blockchain network and an ecosystem that supports a wide array of dApps and use cases. Its architecture is designed for scalability, offering high throughput of up to 65,000 transactions per second, cheap fees and lightning-fast confirmations, making it suitable for demanding applications like decentralized finance (DeFi), non-fungible tokens (NFTs), gaming, and more.</p>"},{"location":"handbook/chapter1/ecosystem/#decentralized-supercomputer","title":"Decentralized Supercomputer","text":"<p>Think of Solana like a vast, decentralized supercomputer spread across the globe. This network is like one huge, shared computer that anyone can use. The blockchain in this system acts like the computer's memory, storing all the information and transactions. Just as your personal computer runs programs, Solana can run dApps. The SOL is like the fuel that powers this computer, used to pay for using its resources. Validators in the network are similar to the different components of a computer, working together to process information.</p>"},{"location":"handbook/chapter1/ecosystem/#interconnected-dapps","title":"Interconnected dApps","text":"<p>When making a dApp, developers can use other dApps that are already deployed on the network and incorporate them in their projects.</p> <p>Example</p> <p>Let's say you want to make an online fantasy trading card game. Instead of coding everything from scratch, you could:</p> <ol> <li>Use an existing dApp that creates unique digital cards (as NFTs).</li> <li>Add another dApp that handles in-game currency and player transactions.</li> <li>Include a dApp that manages player rankings and tournaments.</li> </ol> <p>This is what makes Solana powerful. There are already many tools and dApps that are waiting for people to use and build upon.</p>"},{"location":"handbook/chapter1/infrastructure/","title":"Infrastructure","text":""},{"location":"handbook/chapter1/infrastructure/#nodes","title":"Nodes","text":"<p>Node is a term from graph theory or distributed systems; it is a single participant in a network. The nodes communicate with each other according to the protocol and in a peer-to-peer manner forming the whole blockchain network. Different kinds of nodes serve different purpose, for example:</p> <ul> <li>Validator nodes secure the network by proposing new blocks and voting on the validity of new blocks</li> <li>RPC (Remote Procedure Call) nodes do not participate in voting, they query the network and post new transactions</li> </ul>"},{"location":"handbook/chapter1/infrastructure/#validator-clients","title":"Validator clients","text":"<p>The software that runs on validator nodes is called validator client. If all validators used the same client, a bug or exploit within that client could compromise the whole network. By using different clients, we spread out the risk. This way, if one client has an issue, the network can still stay safe and keep running smoothly.</p> <p>Important</p> <p>Validator client diversity increases resilience and security of the network.</p> <p>As of now, there are four validator clients (some in development):</p> <ul> <li>Agave</li> <li>Jito Labs</li> <li>Firedancer</li> <li>Sig</li> </ul>"},{"location":"handbook/chapter1/infrastructure/#protocol","title":"Protocol","text":"<p>Protocol is a common set of rules network nodes must follow. It defines things like</p> <ul> <li>communication between P2P (peer-to-peer) nodes,</li> <li>transaction format for network participants,</li> <li>any special features,</li> <li>and everything else for the network to operate correctly and for the users to know how to transact over the network.</li> </ul> <p>An essential part of a good protocol for a decentralized blockchain network is the proper incentive setup; this creates the need for its native coin.</p>"},{"location":"handbook/chapter1/infrastructure/#coin","title":"Coin","text":"<p>Coins are used to motivate participation in the network. They are usually awarded to miners or validators with every new block for their role in securing the network and validating transactions. Without the proper incentives, any decentralized blockchain network falls apart.</p> <p>Info</p> <p>The Solana blockchain's native currency is SOL. Within Solana, the smallest unit is called a lamport, where 1 SOL equals 1,000,000,000 lamports.</p>"},{"location":"handbook/chapter1/introduction/","title":"Introduction","text":"<p>Solana is a blockchain platform that allows people to build and use decentralized applications (dApps) and cryptocurrencies. It was created in 2017 by Anatoly Yakovenko and officially launched its mainnet beta in March 2020.</p>"},{"location":"handbook/chapter1/introduction/#blockchain-trilemma","title":"Blockchain Trilemma","text":"<p>The blockchain trilemma refers to a problem that blockchains face when trying to achieve three important things at once:</p> <ul> <li>scalability (being fast and able to handle many transactions)</li> <li>security</li> <li>decentralization (controlled by many people instead of just one group)</li> </ul> <p>Usually, improving one of these aspects can make the others weaker. For example, if a blockchain is very secure and decentralized, it might struggle to process transactions quickly. The main value proposition of Solana is solving the blockchain trilemma, i.e., delivering scalability, decentralization, and security without sacrificing any of the three mentioned features.</p>"},{"location":"handbook/chapter1/introduction/#development-on-solana","title":"Development on Solana","text":"<p>Solana\u2019s ecosystem revolves around the Rust programming language and its ecosystem. Although Rust is the primary language for smart contract development, C and C++ are also supported.</p> <p>Note</p> <p>Solana also provides libraries and tools for JavaScript and TypeScript developers to interact with the blockchain.</p>"},{"location":"handbook/chapter1/security/","title":"Security","text":""},{"location":"handbook/chapter1/security/#sybil-resistance","title":"Sybil Resistance","text":"<p>To prevent a single entity from taking over the network, there must be a mechanism put in place so that no one can just spawn more nodes that can mine or vote (depending on the network) and thus subvert the network reputation system. These dishonest nodes would be able to out-vote honest nodes and start censoring transactions, approving invalid transactions, or changing the entire protocol.</p> <p>Currently, the two most common Sybil resistance mechanisms are:</p> <ul> <li>Proof-of-Work</li> <li>Proof-of-Stake</li> </ul> <p>Proof-of-Work (PoW) employs a model where miners in the network are given a chance to mine a block that is proportional to their hashing power in the network. Miners basically compete with each other which makes PoW-based networks very energy-inefficient. Bitcoin uses PoW mechanism.</p> <p>Proof-of-Stake (PoS) is a type of model for voting-based networks, where a validator is given the power of their vote proportionally to staked coins. In each round one validator is randomly chosen to propose a new block, while others validate it. By eliminating competition among validators, PoS-based networks are significantly more energy-efficient.</p>"},{"location":"handbook/chapter1/security/#consensus","title":"Consensus","text":"<p>To agree on a certain state of a blockchain, network nodes need to reach a consensus. We assume there are malicious nodes in the network. Therefore, the system must be able to withstand not only simple node failures but also attacks to a certain extent. BFT (Byzantine Fault Tolerance) is thus a desired property of such a distributed system.</p> <p>There are three widely used consensus families:</p> <ol> <li>PBFT-like (Practical BFT) algorithm family: Nodes achieve consensus through a series of voting rounds which ensures that the network can function properly even if some nodes are malicious or fail.</li> <li>Nakamoto consensus: This family combines Proof-of-Work with the longest-chain rule. It was invented by Satoshi Nakamoto in 2008.</li> <li>Avalanche Consensus: A new family introduced in 2018. It is a method where network is quickly able to reach consensus by having nodes communicate with small groups of other nodes.</li> </ol>"},{"location":"handbook/chapter1/security/#security","title":"Security","text":"<p>Consensus and Sybil resistance mechanisms are often confused as being the same thing, which is not true and is worth pointing out. One works in conjunction with the other. Let\u2019s look at how this works in both PoW-based and PoS-based networks.</p> <p>Consider what makes Bitcoin, a PoW-based network, theoretically secure \u2013 it is the fact that only the longest chain is respected, also commonly known as the longest chain rule. This is why the consensus is called, as mentioned before, the Nakamoto consensus.</p> <p>For a PoS-based network, the Sybil resistance mechanism is usually associated with a variant of a PBFT-like algorithm or the novel Avalanche consensus.</p> <p>Important</p> <p>Solana uses Proof-of-Stake mechanism coupled with a timekeeping protocol called Proof-of-History.</p>"},{"location":"handbook/chapter1/security/#threat-scenarios-on-bft-networks","title":"Threat Scenarios on BFT networks","text":"<p>In Byzantine Fault Tolerant (BFT) networks, threat scenarios involve attempts to disrupt the consensus process by taking control of validator nodes.</p> <p>Warning</p> <p>It is crucial to maintain validator diversity and decentralization in order to prevent these attacks.</p>"},{"location":"handbook/chapter1/security/#13-attack","title":"1/3 Attack","text":"<p>If an attacker controls just over one-third of the network\u2019s validators, they can prevent the network from reaching consensus, which effectively halts the network.</p>"},{"location":"handbook/chapter1/security/#23-attack","title":"2/3 Attack","text":"<p>The scenario where an attacker controls more than two-thirds of the validators is even more dangerous. This allows them not only to halt the network but also to take over, potentially rewriting the blockchain and compromising its security.</p>"},{"location":"handbook/chapter1/slots-epochs-leaders/","title":"Slots, Epochs and Leaders","text":""},{"location":"handbook/chapter1/slots-epochs-leaders/#slots","title":"Slots","text":"<p>A slot is a 400 milliseconds long time interval, during which a specific validator, known as the leader, is given a chance to propose a new block. This block contains transactions that are ready to be processed within the network. After the block is proposed, other validators review and confirm its validity.</p> <p>Note</p> <p>If a leader fails to propose a block during their assigned slot, the network moves on to the next validator in line.</p>"},{"location":"handbook/chapter1/slots-epochs-leaders/#epochs","title":"Epochs","text":"<p>An epoch is a fixed time period lasting approximately 432,000 slots (about 2 days). Epochs serve as a fundamental unit of time in Solana's ecosystem. They are used to manage stake activations and deactivations, and most importantly, to determine the schedule for leader rotation. At the beginning of each epoch, the network recalculates validator stakes and updates the leader schedule for the upcoming period.</p> <p>Info</p> <p>The probability of a given validator being chosen as a leader is proportional to their stake in the network.</p>"},{"location":"handbook/chapter1/smart-contract/","title":"Smart Contract","text":""},{"location":"handbook/chapter1/smart-contract/#smart-contract","title":"Smart Contract","text":"<p>A smart contract is a piece of code deployed on a blockchain with a cryptographically signed transaction. Users can then interact with it by sending transactions that invoke a specific function defined in the smart contract and the business logic is executed as stated in the deployed code.</p> <p>Data relevant to the smart contract state are also stored on the blockchain. Hence we can look at smart contracts as programs on a decentralized computer that access files in its file system and modify them according to the predefined rules. If such a contract is made immutable, we can trust that the smart contract will not do anything else than what it is supposed to do.</p> <p>Note</p> <p>Apart from storing the blockchain itself, each node creates a state as a result of transaction execution. The final state is the result of all processed transactions and can always be deterministically recreated from the blockchain history.</p>"},{"location":"handbook/chapter1/smart-contract/#isa-and-virtual-machines","title":"ISA and Virtual Machines","text":"<p>Code is compiled for a predefined ISA (Instruction Set Architecture) and executed in a VM (Virtual Machine) which understands it. The mentioned VM is a special runtime environment similar to well-known VMs such as JVM (Java Virtual Machine) or CLR (Common Language Runtime).</p> <p>Info</p> <p>The Solana blockchain's execution environment is called SVM (Solana Virtual Machine). It is written in Rust and enables the blockchain to handle thousands of transactions per second.</p> <p>Note</p> <p>Only transactions involving smart contract execution need to be processed by the VM.</p>"},{"location":"handbook/chapter1/transaction/","title":"Transaction","text":""},{"location":"handbook/chapter1/transaction/#transaction","title":"Transaction","text":"<p>Transaction is a protocol-defined message that is stored as a part of a block, which is then stored as a part of a blockchain. The content usually consists of some kind of value transfer or on-chain program execution. Transactions are cryptographically signed by their authors, proving their authenticity.</p>"},{"location":"handbook/chapter1/transaction/#instruction","title":"Instruction","text":"<p>A transaction is made up of one or more instructions. An instruction is a lower-level command that tells the blockchain what action to perform. These actions can include transferring tokens, interacting with smart contracts, or even creating new accounts.</p> <p>Info</p> <p>Instructions are the building blocks of transactions. A single transaction can contain multiple instructions, allowing it to perform complex operations in one go.</p>"},{"location":"handbook/chapter2/","title":"Core Concepts","text":"<p>Learn the key features that make Solana so fast, efficient and scalable. These eight core concepts are what makes Solana stand out from other blockchains!</p> <p></p> <ul> <li> <p> Proof of History</p> <p>A cryptographic clock that timestamps transactions.</p> <p>Proof of History</p> </li> <li> <p> Tower BFT</p> <p>A consensus mechanism that ensures finality using PoH as a clock reference.</p> <p>Tower BFT</p> </li> <li> <p> Turbine</p> <p>A block propagation protocol that breaks data into smaller packets for faster transmission.</p> <p>Turbine</p> </li> <li> <p> Gulf Stream</p> <p>A mempool system that pushes transactions to validators before confirmation.</p> <p>Gulf Stream</p> </li> <li> <p> Sealevel</p> <p>Solana\u2019s parallel smart contract runtime for simultaneous transaction execution.</p> <p>Sealevel</p> </li> <li> <p> Pipelining</p> <p>A technique that optimizes transaction processing.</p> <p>Pipelining</p> </li> <li> <p> Cloudbreak</p> <p>Solana's custom database that enables fast reads and writes.</p> <p>Cloudbreak</p> </li> <li> <p> Archivers</p> <p>Distributed storage systems that hold and serve off-chain data for Solana\u2019s ledger.</p> <p>Archivers</p> </li> </ul>"},{"location":"handbook/chapter2/archivers/","title":"Archivers","text":""},{"location":"handbook/chapter2/archivers/#distributed-ledger-storage","title":"Distributed Ledger Storage","text":"<p>The Solana blockchain can grow at enormous speed, making it very challenging for each node to store the complete history of transactions. To address this, there is a concept of distributed ledger storage that would store this data in a decentralized fashion for everyone else.</p> <p>Insight</p> <p>At the network speed of 1 Gbps, the Solana blockchain would generate roughly 4 petabytes of data over the course of 1 year.</p> <p>Given how impractical it would be for every validator to keep a full copy of blockchain's history, the idea is to offload the data from validators to these specialized, lightweight network nodes called Archivers. The data is split into many small pieces and replicated so that the full state can always be reconstructed. These specialized nodes are also regularly challenged at the protocol level using a mechanism called Proof of Replication. This ensures that nodes store the correct data and prevents data loss.</p> <p>Note</p> <p>This concept is yet to be implemented.</p>"},{"location":"handbook/chapter2/cloudbreak/","title":"Cloudbreak","text":""},{"location":"handbook/chapter2/cloudbreak/#memory-bottleneck","title":"Memory Bottleneck","text":"<p>As the speed of computation increases, memory access becomes a new bottleneck. LevelDB is the industry-standard local database for storing blockchain data and state. However, it does not support parallel reads and writes. That is fine for Bitcoin or Ethereum, but not for a massively parallel system like Solana.</p> <p>The sheer size of the blockchain state makes storing everything in RAM impractical even for large servers. To combat this, Solana had to invent its own database system that supports parallel reads and writes and scales easily with addition of more disks.</p>"},{"location":"handbook/chapter2/cloudbreak/#cloudbreak","title":"Cloudbreak","text":"<p>Cloudbreak is Solana's custom database. It makes use of memory-mapped files to store data in a way that allows for independent access to each file.</p> <p>Info</p> <p>A memory-mapped file is a file that is mapped to the process\u2019s virtual memory address space and can be accessed directly without further system calls.</p> <p>The speed is still limited by the disk I/O, but we get less overhead, and the kernel can store a part of it in its page cache (also known as file cache).</p> <ul> <li>Reads are randomly distributed among available disks, as the data is stored evenly.</li> <li>Writes use Copy-on-Write semantics, appending new data sequentially to random disks.</li> </ul> <p>Old data entries are garbage collected in order to preserve space for future use. The design of Cloudbreak makes it ideal for hardware setups, such as RAID 0 with fast NVMe SSDs.</p> <p>Note</p> <p>The Cloudbreak database was benchmarked by the Solana team. The results show that even with 10 million accounts, a size that does not fit in RAM, Cloudbreak still achieves nearly 1 million of read and write operations per second with a single SSD.</p>"},{"location":"handbook/chapter2/gulf-stream/","title":"Gulf Stream","text":""},{"location":"handbook/chapter2/gulf-stream/#mempool","title":"Mempool","text":"<p>In traditional blockchains, each node reserves a part of its memory for the memory pool, more commonly known as mempool. The mempool is used to store transactions that are currently being broadcasted over the network but have not yet been added to a block.</p> <p>This creates a big communication overhead where every transaction must reach all nodes in the network. While not all nodes need to be aware of every transaction in the mempool, it is most important for miner and validator nodes (depending on the type of network), which must include them in new blocks.</p> <p>Note</p> <p>If there are more transactions in the mempool than can fit into a block, a backlog of pending transactions is created.</p>"},{"location":"handbook/chapter2/gulf-stream/#gulf-stream","title":"Gulf Stream","text":"<p>Gulf Stream is Solana\u2019s mempool-less solution for forwarding and storing transactions before processing them. Instead of having a single shared mempool, transactions are pushed to the next expected leader. This allows the next leader to quickly receive transactions and start processing them immediately.</p> <p>Info</p> <p>For this to work, the next leader must always be known in advance. In Solana, leader rotation is scheduled one full epoch ahead of time.</p>"},{"location":"handbook/chapter2/pipelining/","title":"Pipelining","text":""},{"location":"handbook/chapter2/pipelining/#pipelining","title":"Pipelining","text":"<p>It is not enough to be able to form a consensus and share a block with the rest of the network quickly. A node must validate and execute all those transactions in received blocks before another block comes. To address this, the Solana team developed the Transaction Processing Unit (TPU). The TPU works as a processor and extensively uses pipelining.</p> <p>Insight</p> <p>Pipelining is a common CPU optimization that helps keep the chip more utilized by splitting an instruction execution into stages. This method allows various hardware components to work in parallel, reducing idle time.</p>"},{"location":"handbook/chapter2/pipelining/#stages-of-the-tpu-pipeline","title":"Stages of the TPU pipeline","text":"<ol> <li>Data fetch: Incoming data is fetched the in kernel space via network card.</li> <li>Signature verification: The GPU handles signature verification.</li> <li>Banking: Update of the state using the CPU.</li> <li>Write: The processed transaction are written to the disk in the kernel space and broadcast via network card to the network.</li> </ol> <p>Info</p> <p>There are two pipelined processes that Solana validators use:</p> <ul> <li>The leader uses Transaction Processing Unit (TPU) to produce a new block.</li> <li>Other validators use Transaction Validation Unit (TVU) to validate and propagate the block produced by the leader.</li> </ul>"},{"location":"handbook/chapter2/proof-of-history/","title":"Proof of History","text":""},{"location":"handbook/chapter2/proof-of-history/#proof-of-history","title":"Proof of History","text":"<p>Achieving agreement on time in distributed systems has always been problematic. Solana uses a timekeeping protocol called Proof of History (PoH) to synchronize local virtual clocks on all nodes. PoH ensures that the timestamp in any message can be trusted and that any timeouts in the consensus protocol can be avoided because every node knows the current time and when to begin a new consensus round.</p> <p>Important</p> <p>Proof of History minimizes block time by eliminating waiting overhead. Thanks to synchronized clocks, communication can be replaced by local computation.</p> <p>To prevent validators from skipping their predecessors, PoH is used to force all validators to complete some computational work making them wait specific amount of time before they can submit their block.</p> <p>Example</p> <p>If validator B follows validator A, B cannot attempt to skip A's block by chaining off the previous block because B has to run the PoH algorithm for at least as long as A did. This gives validator A a fair chance to submit their block.</p> <p>Warning</p> <p>Proof of History is neither a consensus mechanism nor a Sybil resistance mechanism!</p>"},{"location":"handbook/chapter2/proof-of-history/#verifiable-delay-function","title":"Verifiable Delay Function","text":"<p>PoH is based on a Verifiable Delay Function (VDF). Solana uses a recursive, pre-image-resistant SHA-256 VDF, where the output of one SHA-256 iteration is recursively used as the input for the next.</p> <p>To create a block, the producer needs to compute the VDF with all new messages to be included in the block:</p> <pre><code>Message<sub>1</sub> \u2192 Hash<sub>1</sub> \nHash<sub>1</sub> + Message<sub>2</sub> \u2192 Hash<sub>2</sub> \nHash<sub>2</sub> + Message<sub>3</sub> \u2192 Hash<sub>3</sub> \n... \nHash<sub>n-1</sub> + Message<sub>n</sub> \u2192 Hash<sub>n</sub></code></pre> <p>Note</p> <p>Using PoH, we are able establish the exact order of messages because we can prove that Message<sub>n</sub> occured after Message<sub>n-1</sub> and before Message<sub>n+1</sub>.</p>"},{"location":"handbook/chapter2/proof-of-history/#phases-of-poh","title":"Phases of PoH","text":"<ul> <li> <p>Evaluation phase (leader):</p> <p>During this phase computation takes place on only one CPU core, as PoH requires strictly sequential processing by definition.</p> <p>This phase takes:</p> </li> </ul> \\[ \\frac{total\\ number\\ of\\ hashes}{hashes\\ per\\ second\\ for\\ single\\ core} \\] <ul> <li> <p>Verification phase (voters):</p> <p>In verification phase, blocks can be checked in parallel using GPU with thousands of cores since the intermediate hashes are known.</p> <p>This phase takes:</p> </li> </ul> \\[ \\frac{total\\ number\\ of\\ hashes}{hashes\\ per\\ second\\ for\\ single\\ core \\times number\\ of\\ cores\\ available} \\] <p>Important</p> <p>The key takeaway is that while PoH is computationaly intensive to produce, it can be verified very quickly by validators.</p>"},{"location":"handbook/chapter2/sealevel/","title":"Sealevel","text":""},{"location":"handbook/chapter2/sealevel/#sealevel","title":"Sealevel","text":"<p>Sealevel is a runtime developed by the Solana team that allows for the parallel processing of smart contracts. It can process as many transactions as many cores are available in the system. This is a major improvement, making Solana a multi-threaded global state machine.</p> <p>Important</p> <p>A high-level overview of how Sealevel works:</p> <ul> <li>Sort pending transactions.</li> <li>Schedule non-overlapping transactions to run in parallel.</li> </ul> <p>The reason this is possible with Solana is that each and every transaction explicitly defines states it will read from and write to. Sealevel can then choose non-overlapping instructions to be executed in parallel. Additionally, transactions that only read certain states can be executed in parallel as well.</p> <p>Note</p> <p>Other blockchains operate as single-threaded global state machines. The only thing they might do in parallel is signature verification.</p>"},{"location":"handbook/chapter2/sealevel/#berkeley-packet-filter","title":"Berkeley Packet Filter","text":"<p>The standard way to execute code on a blockchain is to use a Virtual Machine (VM) and compile the code, written in various supported languages, into bytecode. This code then gets deployed to the blockchain, and when the user sends a transaction invoking the contract, the code gets loaded into the VM and executed.</p> <p>Ethereum does this using its own Ethereum Virtual Machine (EVM). Some other blockchains make use of Web Assembly (WASM). Solana iterated through several solutions and chose a variant of the Berkeley Packet Filter (BPF) for its virtual machine.</p> <p>Sealevel hands off transactions to the VM, where they are executed as BPF bytecode. BPF and its extended version, eBPF, originally designed for high-performance packet filtering in networking systems, are in-kernel VMs available in most UNIX-like operating systems.</p> <p>Important</p> <p>Solana uses Rust Berkeley Packet Filter (rBPF) which is a modified version of eBPF optimized for Solana's architecture.</p>"},{"location":"handbook/chapter2/tower-bft/","title":"Tower BFT","text":""},{"location":"handbook/chapter2/tower-bft/#tower-byzantine-fault-tolerance","title":"Tower Byzantine Fault Tolerance","text":"<p>Solana uses Tower Byzantine Fault Tolerance (TBFT) as its consensus algorithm, which is a custom implementation of the Practical Byzantine Fault Tolerance (PBFT) algorithm published in 1999 by Miguel Castro and Barbara Liskov.</p> <p>The goals of PBFT are to ensure:</p> <ul> <li>Safety - Results are valid and identical across all non-faulty nodes.</li> <li>Liveness - Nodes that don\u2019t fail will always produce a result.</li> </ul> <p>Note</p> <p>Safety is guaranteed because the process is deterministic, meaning it always produces the same results across all non-faulty nodes. The liveness guarantee is enabled by the view-change mechanism, which allows nodes to switch leaders if the current leader appears to be malicious or faulty.</p>"},{"location":"handbook/chapter2/tower-bft/#view-change","title":"View-change","text":"<p>View-changes occur when a leader appears to have failed, and so another node attempts to take his place by initiating an election process. This process is triggered by timeouts that prevent nodes from waiting indefinitely for unexecuted requests. The timeout is postponed whenever the protocol detects that nodes are nearing agreement on the current block.</p>"},{"location":"handbook/chapter2/tower-bft/#tbft-vs-pbft","title":"TBFT vs PBFT","text":"<p>TBFT is a variation of PBFT, with one key difference. Proof of History provides a global source of time before consensus is reached and can therefore be used to enforce the exponentially increasing timeouts introduced in the original PBFT algorithm. No additional messages are needed because PoH itself enforces the timeouts, thereby reducing communication overhead.</p>"},{"location":"handbook/chapter2/turbine/","title":"Turbine","text":""},{"location":"handbook/chapter2/turbine/#turbine","title":"Turbine","text":"<p>Turbine is a block propagation protocol designed to reduce both time needed for block propagation as well as the overall message complexity, reducing the communication overhead of a node.</p> <p>Nodes in the network are divided into small partitions called neighborhoods. Nodes within a particular neighborhood are responsible for sharing received data with other nodes in the same neighborhood and propagating the data to a small number of nodes in other neighborhoods.</p> <p> </p> <p>Info</p> <p>The data unit shared is called a shred, and each block is composed of many shreds.</p>"},{"location":"handbook/chapter2/turbine/#problems-with-broadcasting-and-solutions","title":"Problems with Broadcasting and Solutions","text":"<p>Since we are in an adversarial environment, any node can decide not to rebroadcast the received shreds or broadcast incorrect data.</p> <p>Countermeasures:</p> <ul> <li> <p>Erasure Codes help by broadcasting a block with more shreds than necessary to reconstruct the entire block without errors, even if some shreds are lost along the way. With 6 data shreds and 3 additional redundant shreds, we can lose up to 1/3 of the shreds and still be able to reconstruct the entire block fully.</p> </li> <li> <p>A stake-weighted selection algorithm is used to create a tree where the risk of faulty or malicious nodes is minimized. Validators with the highest stake are positioned closer to the current leader.</p> </li> </ul>"},{"location":"handbook/chapter3/","title":"Programming Model","text":"<p>Learn how to interact with the network and dive into concepts like transactions, accounts, and runtime policy that define how programs operate on Solana.</p> <p></p> <ul> <li> <p> Interacting with the Network</p> <p>Learn how to interact with Solana's blockchain using different tools.</p> <p>Interacting with the Network</p> </li> <li> <p> Transaction Lifecycle</p> <p>Explore the journey of a transaction on Solana.</p> <p>Transaction Lifecycle</p> </li> <li> <p> Transaction Anatomy</p> <p>Understand what makes up a transaction on Solana.</p> <p>Transaction Anatomy</p> </li> <li> <p> Account Anatomy</p> <p>Learn the structure of accounts as well as their purpose.</p> <p>Account Anatomy</p> </li> <li> <p> Runtime Policy</p> <p>Learn the rules enforced by Solana\u2019s runtime to ensure system security.</p> <p>Runtime Policy</p> </li> <li> <p> Program Derived Address</p> <p>Understand program derived addresses and how they differ from regular pubkeys.</p> <p>Program Derived Address</p> </li> <li> <p> Cross Program Invocation</p> <p>Explore how programs on Solana interact with each other.</p> <p>Cross Program Invocation</p> </li> </ul>"},{"location":"handbook/chapter3/account-anatomy/","title":"Account Anatomy","text":""},{"location":"handbook/chapter3/account-anatomy/#everything-is-an-account","title":"Everything is an Account","text":"<p>Just as in UNIX, where \"everything is a file\", in Solana \"everything is an account\". In other words, an account is a memory buffer that functions similarly to a file in a file system. The main purpose of an account is to store state between instructions and transactions. Each account is identified by an address (a public key) and Solana\u2019s account system can therefore be viewed as  key-value database.</p> <p>Note</p> <p>The key may be one of the following:</p> <ul> <li>An ed25519 public key.</li> <li>A program derived address (PDA).</li> </ul>"},{"location":"handbook/chapter3/account-anatomy/#account-anatomy","title":"Account Anatomy","text":"<p>1. Lamports</p> <ul> <li>The account balance is held in lamports.</li> <li>1 lamport = 10<sup>\u22129</sup> SOL.</li> </ul> <p>2. Data</p> <ul> <li>Vector of bytes.</li> <li>The maximum account data size is 10 MB.</li> </ul> <p>Warning</p> <p>For PDAs, the limit is 10 KB at the time of creation, but they can later be resized to a maximum of 10 MB.</p> <p>3. Owner</p> <ul> <li>The owner is either a program ID or a loader in case of an executable account.</li> <li>All new accounts are owned by the System program which allows:<ul> <li>Transfer of lamports.</li> <li>Data allocation.</li> <li>Assignment of ownership to a different program ID.</li> </ul> </li> </ul> <p>Info</p> <p>Program is granted write access only if the owner matches its ID (program owns the account).</p> <p>Important</p> <p>An account is always owned either by a program or a loader.</p> <p>4. Executable</p> <ul> <li>Turning a non-executable account into an executable one is a one-way only operation.</li> <li>The owner of such an account is a loader that will load the code from the data field of the account and start executing it if invoked.</li> </ul> <p>Note</p> <p>Account becomes read-only it is made executable.</p> <p>5. Rent Epoch</p> <ul> <li>To maintain an account on Solana, a fee called rent has to be paid periodically.</li> <li>An account is considered rent-exempt if it holds at least two years\u2019 worth of rent.</li> <li>Every epoch runtime checks whether the account should pay rent or is rent-exempt.</li> </ul>"},{"location":"handbook/chapter3/account-anatomy/#account-types","title":"Account Types","text":"<p>There are 3 types of Solana accounts:</p> <ol> <li>Data accounts - These accounts serve as containers for storing and retrieving data.</li> <li>Program accounts - These accounts store user-deployed executable bytecode.</li> <li>Native accounts - These accounts hold Solana's built-in programs such as the System program, the BPF Loader, and others.</li> </ol>"},{"location":"handbook/chapter3/cross-program-invocation/","title":"Cross Program Invocation","text":""},{"location":"handbook/chapter3/cross-program-invocation/#cross-program-invocation","title":"Cross Program Invocation","text":"<p>A Cross Program Invocation (CPI) is a mechanism that allows Solana programs to call other programs from within an instruction. The caller is halted until execution returns from the callee.</p> <p>Programs can extend their signer privileges to other programs using CPIs. CPIs are executed by calling either invoke or invoke_signed methods within their instructions:</p> <ul> <li>invoke - All necessary signatures are already available before the call.</li> <li>invoke_signed - Calling program needs PDAs to act as signers during the CPI.</li> </ul> <p>Info</p> <p>After a CPI to another program is made, the callee program can make further CPIs to other programs. The maximum CPI depth is 4.</p> <p>CPIs are a very powerful feature as they allow developers to make use of other deployed programs and continuously build on and expand the Solana's already existing ecosystem.</p>"},{"location":"handbook/chapter3/interacting-with-the-network/","title":"Interacting with the Network","text":""},{"location":"handbook/chapter3/interacting-with-the-network/#rpc-requests","title":"RPC Requests","text":"<p>Any user who chooses to interact with the network must communicate with one of the network\u2019s nodes through a Remote Procedure Call (RPC) endpoint. The available RPC methods are listed in the Solana documentation.</p> <p>The methods vary from simple queries, such as retrieving specific account information, or checking the state of the network, to sending transactions that modify state of the blockchain.</p> <p>Example</p> <p>Request of the getBlockHeight method:</p> <pre><code>curl https://api.mainnet-beta.solana.com -X POST -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"getBlockHeight\",\"params\":[]}'\n</code></pre> <p>Response of the getBlockHeight method:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"result\":269624245,\"id\":1}\n</code></pre> <p>Important</p> <p>The ability to send transactions is crucial because is the only way we can alter data on the blockchain. All write operations, including account creation or transfer of tokens are done through transactions.</p> <p>Info</p> <p>While users can interact with the blockchain through RPCs, it is not required. There are several libraries that provide convenient interfaces for languages such as JavaScript, Rust and Python.</p>"},{"location":"handbook/chapter3/interacting-with-the-network/#solana-cli","title":"Solana CLI","text":"<p>Typically, you will not be interacting with the network through raw RPC requests. Instead, you will often use a wrapper around them such as the interfaces mentioned above. Solana's Command-Line Interface (CLI) is a powerful tool that provides a more user-friendly experience for interacting with the blockchain.</p> <p>Example</p> <p>Solana CLI allows you to:</p> <ul> <li> <p>Generate a keypair <pre><code>solana-keygen new\n</code></pre></p> </li> <li> <p>View your public key <pre><code>solana-keygen pubkey\n</code></pre></p> </li> <li> <p>Check account balance <pre><code>solana balance &lt;account-address&gt;\n</code></pre></p> </li> <li> <p>Airdrop SOL (available on Devnet and Testnet) <pre><code>solana airdrop 1 &lt;account-address&gt;\n</code></pre></p> </li> </ul> <p>For more detailed information, checkout the documentation.</p>"},{"location":"handbook/chapter3/program-derived-address/","title":"Program Derived Address","text":""},{"location":"handbook/chapter3/program-derived-address/#program-derived-address","title":"Program Derived Address","text":"<p>Programs can issue instructions that include accounts that were not signed in the original transaction by using Program Derived Addresses (PDAs). These accounts are referred to as PDA accounts. PDAs allow for programmatically generated addresses to be used without needing a private key when invoking instructions of other programs.</p> <p>PDA is an address deterministically derived from the program ID and supplied seeds (keywords). However, the resulting address is bumped off the Ed25519 curve with a so-called bump seeds. This ensures that no private key exists for the PDA.</p>"},{"location":"handbook/chapter3/program-derived-address/#pda-generation","title":"PDA Generation","text":"<p>When generating a PDA there is approximately 50% chance that the address will fall on the elliptic curve, meaning it has a corresponding private key. To avoid this, system uses bump seeds, an 8-bit number, to \"bump\" the address off the curve.</p> <p></p> <p>Insight</p> <p>To find a suitable bump seed, the program iterates through possible values from 255 down to 0. The first bump that works is known as the canonical bump.</p> <p>Warning</p> <p>Other bump seeds beyond the canonical bump may also result in a valid PDA. However, for security reasons, it is recommended to only use the canonical bump.</p> <p>When a program tries to invoke a CPI with PDA, the runtime takes the supplied keywords and bump seeds, uses the caller\u2019s program ID, and repeats the process. If the resulting PDA matches, the account is considered to be signed.</p>"},{"location":"handbook/chapter3/runtime-policy/","title":"Runtime Policy","text":""},{"location":"handbook/chapter3/runtime-policy/#runtime-policy","title":"Runtime Policy","text":"<p>Runtime policy is a set of rules enforced by the runtime to ensure security of the system:</p> <ol> <li> <p>Account Modification</p> <p>The contents of an account can only be modified by the program that owns the account. When an account is assigned to a program, its data is initialized to zero.</p> </li> <li> <p>Conservation of Balances</p> <p>The sum of balances across all accounts must not change before and after transaction execution.</p> </li> <li> <p>Read-Only Account Balances</p> <p>The balances of all read-only accounts cannot be changed by any program during transaction execution.</p> </li> <li> <p>Atomic Transaction Execution</p> <p>All instructions are executed atomically. If any instruction fails, the entire transaction fails.</p> </li> </ol>"},{"location":"handbook/chapter3/runtime-policy/#compute-budget","title":"Compute Budget","text":"<p>Each transaction is allocated a compute budget to prevent abuse of node resources that could potentially lead to network failures or denial of service. When the program consumes its entire compute budget or exceeds certain bounds, the runtime halts the currently running instructions and returns an error.</p>"},{"location":"handbook/chapter3/transaction-anatomy/","title":"Transaction Anatomy","text":""},{"location":"handbook/chapter3/transaction-anatomy/#key-elements","title":"Key Elements","text":"<p>Important</p> <p>Signature A 64 bytes long digital signature in the ed25519 format that verifies the authenticity and integrity of a transaction.</p> <p>Account A record in the Solana ledger that serves as a storage space for user data or an executable program.</p> <p>Compact Array An array-like data structure that starts with a 16-bit encoded array length, followed by the array elements.</p> <p>Blockhash A unique hash that identifies a block produced as a part of the Proof of History algorithm.</p> <p>Program ID The public key of an account that stores a compiled program on the blockchain.</p> <p>Instruction A command that specifies the Program ID to be executed, the accounts involved, and additional data that the program can use to determine the action to be performed.</p>"},{"location":"handbook/chapter3/transaction-anatomy/#transaction-anatomy","title":"Transaction Anatomy","text":"<p>Solana transactions consist of two major parts in the following order:</p> <ul> <li>A compact array of signatures.</li> <li>A message that contains a compact array of account addresses, a recent blockhash and a compact array of instructions.</li> </ul> <p></p>"},{"location":"handbook/chapter3/transaction-anatomy/#signatures","title":"Signatures","text":"<p>For each signature in the compact array, the Solana verifies two conditions:</p> <ul> <li>The number of signatures must match the first 8 bits of the message header.</li> <li>Each signature is validated against the corresponding public key at the same index in the account addresses array.</li> </ul>"},{"location":"handbook/chapter3/transaction-anatomy/#message-layout","title":"Message Layout","text":"<p>1. Header</p> <ul> <li>Number of required signatures in the transaction (8 bits).</li> <li>Number of read-only accounts requiring signatures (8 bits).</li> <li>Number of read-only accounts not-requiring signatures (8 bits).</li> </ul> <p>2. Accounts</p> <ul> <li>Addresses that require signatures with read-write access.</li> <li>Addresses that require signatures with read-only access.</li> <li>Addresses that do not require signatures with read-write access.</li> <li>Addresses that do not require signatures with read-only access.</li> </ul> <p>3. Recent blockhash</p> <ul> <li> <p>Ensures transaction lifetime</p> <p>Transaction is deemed invalid if the blockhash is older than 150 blocks (approximately 1 minute).</p> </li> <li> <p>Prevents transaction replay</p> <p>By tying each transaction to a unique recent blockhash, Solana ensures that identical transactions cannot be processed more than once.</p> </li> </ul> <p>4. Instructions with the following anatomy:</p> <ul> <li>Program ID index.</li> <li>Compact-array of account address indices.</li> <li>Compact-array of opaque 8-bit data (what operations to perform and any additional data).</li> </ul> <p></p>"},{"location":"handbook/chapter3/transaction-lifecycle/","title":"Transaction Lifecycle","text":""},{"location":"handbook/chapter3/transaction-lifecycle/#transaction-lifecycle","title":"Transaction Lifecycle","text":"<p>The following steps can be thought of as an overview of what happens when an app or any user interacts with the Solana network by sending a transaction.</p> <ol> <li> <p>The user or app submits a transaction with one or more instructions to a node that accepts RPC requests.</p> </li> <li> <p>The transaction is then forwarded, according to the leader schedule, to the next leader.</p> </li> <li> <p>The leader validates the transaction, processes it, and includes it in a new block. This block is then broadcasted to all other validators who also validate and process the transaction.</p> </li> <li> <p>During the transaction processing, instructions are executed by the previously deployed programs, and relevant accounts are modified accordingly.</p> </li> </ol> <p>Important</p> <p>Everything happens in an isolated virtual machine. Instructions are executed sequentially and atomically, which means that either all instructions in the transaction complete successfully or none of the changes are applied.</p>"},{"location":"handbook/chapter4/","title":"Solana Program Library","text":"<p>The Solana Program Library (SPL) is a collection of on-chain programs. These programs facilitate tasks like creation and management of tokens and more.</p> <p></p> <ul> <li> <p> Token Program</p> <p>Solana's core program for creating and managing tokens.</p> <p>Token Program</p> </li> <li> <p> Mint Account</p> <p>Represents a specific type of token and stores global metadata.</p> <p>Mint Account</p> </li> <li> <p> Token Account</p> <p>Tracks the ownership and balance of tokens.</p> <p>Token Account</p> </li> <li> <p> Token-2022</p> <p>An updated token standard with additional features.</p> <p>Token-2022</p> </li> <li> <p> Account Compression</p> <p>Enables data compression, lowering costs for NFTs and other tokenized assets.</p> <p>Account Compression</p> </li> </ul>"},{"location":"handbook/chapter4/account-compression-program/","title":"Account Compression","text":""},{"location":"handbook/chapter4/account-compression-program/#merkle-tree","title":"Merkle Tree","text":"<p>A Merkle tree is a data structure that organizes data into a tree-like form.</p> <ul> <li>Each leaf node inside this tree represents a hash of some data.</li> <li>Each non-leaf node represents a hash of its child nodes.</li> </ul> <p>The root is a compact representation of all data stored in the tree. Merkle trees allows us to easily verify integrity of the data without having to store all of it on-chain.</p> Tree Terminology <p>Tree is a term from graph theory and it refers to a type of a graph.</p> <ul> <li>Root node is the top-most node of a tree, which does not have a parent. (example node A)</li> <li>Non-leaf node is a node that does have children in the tree. (example nodes A and B)</li> <li>Leaf node is a node that does not have any children in the tree. (example nodes C, D and E)</li> </ul> Example Tree Graph<pre><code>           A is the root of the tree   A\n                                      / \\\n    B is a parent of nodes D and E   B   C\n                                    / \\\n          D is a child of node B   D   E\n</code></pre>"},{"location":"handbook/chapter4/account-compression-program/#account-compression-program","title":"Account Compression Program","text":"<p>Minting a single NFT may be relatively inexpensive, however, the cost of storing the asset's data on-chain can quickly become uneconomical as the quantity increases.</p> <p>The Account Compression Program is an on-chain system designed to address the rising concern of storage costs on Solana.</p> <p>The solution lies in storing a compressed hash of the asset data on-chain, while the actual data is stored off-chain in a database.  The data is split into pieces, a Merkle tree is built and only the Merkle root is stored on-chain.</p> <p>Info</p> <p>The account compression program uses a special type of Merkle tree called a concurrent Merkle tree. Concurrent Merkle trees allow simulataneous data changes to occur while still maintaining the integrity of the tree.</p>"},{"location":"handbook/chapter4/account-compression-program/#zero-knowledge-compression","title":"Zero-Knowledge Compression","text":"<p>Important</p> <p>Zero-knowledge (ZK) proofs allow one party to prove to another party that some statement is true without revealing any information about the statement itself.</p> <p>ZK proofs can be used to further reduce the amount of data that needs to be stored on a blockchain. With ZK proofs, we can verify that certain calculations or balances are correct without needing to store or reveal the underlying data.</p>"},{"location":"handbook/chapter4/mint-account/","title":"Mint Account","text":"<p>The mint account represents a specific type of token by storing the token's global metadata. The mint account contains these data fields:</p> <ul> <li>Supply: Total supply of the token.</li> <li>Decimals: The number of decimal places the token can be divided into.</li> <li>Mint authority: The account authorized to mint new tokens. (Optional)</li> <li>Freeze authority: The account authorized to freeze token transfers. (Optional)</li> </ul> <p>Tip</p> <p>Check out the mint accounts for USDC and wBTC.</p>"},{"location":"handbook/chapter4/token-2022/","title":"Token-2022","text":"<p>The Token-2022 Program extends the functionality provided by the Token Program. This means that the Token-2022 program is not only backward compatible but also includes all the functions of the original Token program, as well as additional functionality often referred to as token extensions.</p> <p>Info</p> <p>One associated token account program still creates token accounts for both Token and Token-2022.</p> <p>Tip</p> <p>To see the source code, check out Solana Program Library Token-2022 Program.</p>"},{"location":"handbook/chapter4/token-2022/#benefits","title":"Benefits","text":"<ul> <li> <p>Flexibility</p> <p>Some token extension are incompatible, however, you can create a variety of custom combinations that fit your needs.</p> </li> <li> <p>Reduced risk</p> <p>Using audited and well-tested extensions helps protect protocols and funds.</p> </li> <li> <p>Reduced testing costs</p> <p>Extensions are added by specifying the extensions in code, this reduces number of errors and saves time on testing.</p> </li> <li> <p>Reduced development time</p> <p>Extensions are uniform and reusable, which significantly speeds up development.</p> </li> </ul>"},{"location":"handbook/chapter4/token-2022/#extensions","title":"Extensions","text":"<p>There are two types of extensions:</p> <ul> <li>Mint Extensions</li> <li>Token Account Extensions</li> </ul> <p>Note</p> <ul> <li>Mint extensions are added on top of the original Solana Token Program and extend the capabilities of tokens.</li> <li>Token account extensions are added on top of Solana accounts and add account-related features.</li> </ul> <p>Mint extensions:</p> <ul> <li>Confidential transfers: Confidential transactions that do not reveal the amount transferred.</li> <li>Transfer fees: Collection of fees on each transfer. The fees are then sent to a specified account.</li> <li>Mint close authority: Enables mint owners to close their accounts and reclaim the lamports.</li> <li>Transfer hook: Calls specific programs when a token transfer occurs.</li> <li>Interest-bearing tokens: Set an interest rate on a token. The interest can be tracked and displayed.</li> <li>Non-transferable tokens:  Restrict token transfers between users.</li> <li>Permanent delegate: Permanently assign a delegate that has the authority to manage token accounts of a given mint.</li> <li>Metadata pointer: Allows token creators to link an external address that contains the official metadata of the token.</li> <li>Metadata:  Allows integration of metadata into tokens through custom fields.</li> </ul> <p>Token account extensions include:</p> <ul> <li>Memo required on transfer: Requires an attached memo as a message during each token transfer.</li> <li>Immutable owner: Makes it impossible to reassign ownership of an account.</li> <li>Default account state: Freezes all new token accounts so that users must interact with the project in some way to unfreeze the accounts/tokens.</li> <li>CPI guard: Restricts how other programs can interact with your token by prohibiting certain actions inside cross-program invocations.</li> </ul> <p>Note</p> <p>You can find a list of Token-2022 extensions in the documentation.</p>"},{"location":"handbook/chapter4/token-account/","title":"Token Account","text":"<p>A token account on Solana is a general term for any account that holds tokens. Token accounts are created by the Token Program and store different types of tokens. Every account has a unique mint address, and a token account holds tokens of a specific mint account.</p> <p>The Token Program is the owner of a token account. However, another account can be specified as the authority with the ability to transfer tokens. This means that while the Token Program manages the structure of the token account, another account controls the movement of tokens.</p>"},{"location":"handbook/chapter4/token-account/#token-account-structure","title":"Token Account Structure","text":"<p>The structure of a token account resembles that of a regular account. It holds lamports, has an executable flag (set to false), owner (Token Program) and stores additional data.</p> <p>These data fields provide enhanced account management features. For example, you can specify a delegate account, which can then spend tokens up to a delegated_amount.</p> <p>Main fields:</p> <ul> <li>Mint: The type of token the account holds.</li> <li>Owner: The account with authority to transfer the tokens.</li> <li>Amount: The number of tokens the account holds.</li> </ul> <p>Additional fields:</p> <ul> <li>Delegate: Delegate authority having possession over delegate amount. (Optional)</li> <li>IsNative: Specifies whether the token account holds wrapped SOL. (Optional)</li> <li>Delegate amount: Amount authorized by the delegate authority.</li> <li>Close Authority: Authority able to close the Token Account. (Optional)</li> </ul>"},{"location":"handbook/chapter4/token-account/#associated-token-account","title":"Associated Token Account","text":"<p>An Associated Token Account (ATA) is a token account, but its address has a special property.</p> <p>Important</p> <p>An Associated Token Account address is derived (as a PDA) from its owner's wallet address and the address of the mint.</p> <p>This means that user has a different ATA for every wallet and token mint combination. This is very convenient because programs can easily find and interact with the correct account without needing the user to provide the address.</p> <p>Info</p> <p>A user can receive tokens even if they do not yet have a token account for that mint. The sender is able to fund the creation of the receiver's ATA, enabling things like airdrop campaigns.</p> <p>Associated Token Account Program facilitates the creation and management of ATAs.</p>"},{"location":"handbook/chapter4/token-program/","title":"Token Program","text":""},{"location":"handbook/chapter4/token-program/#fungible-and-non-fungible-tokens","title":"Fungible and Non-Fungible Tokens","text":"<p>Fungible Tokens: These tokens are interchangeable with one another. They are indistinguishable and hold the same value.</p> <p>Non-Fungible Tokens (NFTs): Each NFT is a special digital asset that holds a unique information or value. NFTs can represent ownership of a specific digital or physical item, such as digital art or real estate.</p>"},{"location":"handbook/chapter4/token-program/#token-program","title":"Token Program","text":"<p>Token Program defines a common implementation for fungible and non-fungible tokens. All tokens on Solana are created using the SPL Token Program.</p> <p>Tip</p> <p>To see the source code, check out Solana Program Library Token Program.</p> <p>Info</p> <p>Solana's SPL tokens are similar to Ethereum's ERC-20 or ERC-721 standards. However, Solana does not require you to deploy a new contract for each token you create. Instead, you simply send instructions to the Token Program, which will create and mint tokens on your behalf.</p> <p></p>"},{"location":"handbook/chapter4/token-program/#creating-tokens","title":"Creating Tokens","text":"<p>A token can be created by initializing a new mint account. The mint account is used to create and hold info about new tokens, which are then stored in token accounts. Once a mint account is initialized, the mint_authority can create (mint) new tokens using the MintTo instruction.</p> <p>Important</p> <p>As long as mint account contains a valid mint_authority, it is considered to have a non-fixed supply, and the mint_authority can create new tokens with the MintTo instruction at any time.</p>"},{"location":"handbook/chapter4/token-program/#transferring-tokens","title":"Transferring Tokens","text":"<p>Balances can be transferred between accounts using the Transfer instruction, with the source account owner required as a signer when the accounts differ.</p>"},{"location":"handbook/chapter4/token-program/#burning-tokens","title":"Burning Tokens","text":"<p>The Burn instruction decreases an account's token balance without transferring to another account. The burnt tokens are permanently removed from the circulation, and this action can be verified on chain.</p>"},{"location":"handbook/chapter4/token-program/#freezing-accounts","title":"Freezing Accounts","text":"<p>The mint account may include a freeze_authority, allowing it to invoke FreezeAccount instruction that will make account unusable. Frozen accounts can be reactivated using the ThawAccount instruction and freeze_authority can be changed using the SetAuthority instruction.</p>"},{"location":"handbook/chapter4/token-program/#wrapping-sol","title":"Wrapping SOL","text":"<p>SOL can be wrapped and used like a Token Program token when interacting with programs that use the Token Program's interface. Accounts that hold wrapped SOL are associated with Native Mint. Wrapped SOL token accounts have unique behaviors, which you can learn more about here.</p>"}]}