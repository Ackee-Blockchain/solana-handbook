{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Solana was introduced by Anatoly Yakovenko in 2017 when the Solana Whitepaper was published. However, the whitepaper is no longer up-to-date and we haven\u2019t found documentation that would meet our needs - to provide study material for the School of Solana. That is why this handbook was created. Its purpose is to introduce the reader to the Solana blockchain. It should serve as an entry point for new Solana developers or blockchain enthusiasts wishing to learn about Solana.</p> <p>The handbook is structured as follows:</p> <ul> <li>Beginning with Chapter 1, Blockchain Terminology, it clarifies fundamental concepts.</li> <li>Chapter 2, Solana Introduction, provides initial insights into Solana.</li> <li>Chapter 3, Solana Core Concepts, delves deeply into the platform's foundational ideas.</li> <li>Chapter 4, the Programming Model, talks about its operational framework.</li> <li>Continuing, Chapter 5, Solana Program Library discusses available resources provided by the Program Library.</li> </ul> <p>Appendices cover various domains:</p> <ul> <li>Appendix A - Ecosystem, introduces you into the Solana Ecosystem.</li> <li>Appendix B - NFT, provides technical insights into NFTs.</li> <li>Appendix C - Gaming, details about upcoming Web3 and Games.</li> </ul> <p>This comprehensive handbook functions as an ideal primer for those embarking on a journey to understand Solana. We wholeheartedly welcome any input, by identifying errors or suggesting expansions, to enhance this resource.</p>"},{"location":"handbook/authors/","title":"About Authors","text":"<p>This handbook was created with love by Solana Auditors and Developers of Ackee.</p> <p>Ackee is a blockchain security company founded in 2021, specializing in audits and other security assessments. Its team of experts performs Ethereum and Solana audits and develops open-source security frameworks Wake and Trident.</p> <p>By running free certification courses: the School of Solana and the School of Solidity, Ackee contributes to a stronger blockchain ecosystem by sharing knowledge.</p>"},{"location":"handbook/appendixA/popular-projects/","title":"Popular Projects","text":"<p>Solana's blockchain has become a fertile ground for innovation, attracting numerous high-profile projects due to its speedy, reliable, and scalable solutions for blockchain applications and technologies. Below, we've curated a list of some of the best-known names in their respective domains, but don't be misled; this is just the tip of the iceberg. There are many more applications and projects thriving on the Solana platform, contributing to a vibrant and continually expanding ecosystem.</p>"},{"location":"handbook/appendixA/popular-projects/#derivatives","title":"Derivatives","text":"<p>Derivatives are products including options, futures, collateralized loans, and prediction markets, where an arrangement or instrument has a value derived from the underlying asset.</p> <ul> <li>HXRO</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#decentralized-exchanges-on-solana","title":"Decentralized exchanges on Solana","text":"<p>Decentralized exchanges (DEXs) are a pivotal innovation in the world of cryptocurrency, allowing users to trade assets directly with one another without the need for an intermediary or centralized entity. Unlike traditional exchanges, where the exchange controls the user's funds, DEXs operate on smart contracts that handle the trading process. This design enhances security and privacy, as users retain control over their private keys. While offering benefits like reduced risk of hacking and censorship resistance, DEXs may face challenges such as lower liquidity and higher fees compared to centralized counterparts. Nevertheless, they represent a significant step towards a more decentralized and transparent financial ecosystem.</p> <ul> <li>Orca</li> <li>Raydium</li> <li>Saber</li> <li>Jupiter Aggregator</li> <li>Mango Markets</li> <li>Drift Protocol</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#solana-liquid-staking","title":"Solana Liquid Staking","text":"<p>Liquid staking is a financial innovation within the crypto space that allows users to stake their assets while still having access to liquidity. Essentially, it lets participants earn staking rewards without locking up their tokens, by issuing synthetic or derivative tokens in return. This flexibility fosters greater participation and efficiency in proof-of-stake networks.</p> <ul> <li>Lido</li> <li>Marinade Finance</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#decentralized-lending-on-solana","title":"Decentralized Lending on Solana","text":"<p>Decentralized lending refers to peer-to-peer lending practices conducted on blockchain networks. By using smart contracts, it eliminates traditional financial intermediaries, allowing users to borrow or lend funds directly to one another. This offers more accessible and potentially lower-cost lending options, promoting financial inclusion and greater control over personal finance.</p> <ul> <li>Solend</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#marketplaces","title":"Marketplaces","text":"<p>There are multiple NFT marketplaces to trade NFTs (see Chapter 7 for more about NFTs), which are theoretically supposed to represent a certificate of ownership of something. The trend of NFTs is closely coupled with an old-new concept of Metaverse, an artificial world where people could meet as virtual avatars and show off their collectible NFTs. NFTs may find useful applications in the future for representing real-world items, such as concert tickets, but it remains to be seen if they offer any real advantage in practice or if the technology continues to be used largely for speculation.</p> <ul> <li>MagicEden</li> <li>Tensor</li> <li>Solanart</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#analytics","title":"Analytics","text":"<p>Analytics tools on blockchain provide insights into transactions, network health, and user behavior. They enable transparency, traceability, and data-driven decision-making, enhancing efficiency and trust within the decentralized ecosystem.</p> <ul> <li>DefiLlama</li> <li>Dune Analytics</li> <li>Nansen</li> <li>VybeNetwork</li> <li>Step Finance</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#tooling","title":"Tooling","text":"<p>Tools that enhance the safety of smart contracts facilitate thorough testing and validation, detecting vulnerabilities and errors. They improve the overall workflow of developing decentralized applications, ensuring robustness and security. Additionally, they enhance the usability of existing smart contracts, making them more accessible and efficient for users.</p> <ul> <li>Solana Anchor Framework</li> <li>Trident Testing and Fuzzing Framework</li> <li>Solang</li> <li>Metaplex</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#gaming","title":"Gaming","text":"<p>First games built on Solana are starting to appear, using the blockchain as a back end (see Appendix C for more about gaming) \u2013 this type of development paradigm is referred to as Web3. In general, any application using blockchain as a layer of data and business logic can be considered Web3. When a user visits such a website, they can usually connect their wallet with the website and interact with it by sending transactions that could, e.g., post a message on a Web3 social media platform or place an order on a decentralized exchange.</p> <ul> <li>Star Atlas</li> <li>xNFTs with BackPack</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#real-world-projects","title":"Real World Projects","text":"<p>The remarkable benefits of the Solana Blockchain make it a magnet for projects affiliated with real-world applications.</p> <ul> <li>Helium</li> <li>Render Network</li> <li>HiveMapper</li> </ul>"},{"location":"handbook/appendixA/popular-projects/#bridges","title":"Bridges","text":"<p>Crosschain bridges enable the transfer of assets and information between different blockchain networks. They enhance interoperability, allowing seamless transactions across various platforms, thus expanding possibilities within the decentralized ecosystem.</p> <ul> <li>Wormhole</li> <li>DeBridge Finance</li> </ul>"},{"location":"handbook/appendixA/solana-mobile-phone/","title":"Solana Mobile Phone","text":"<p>As you may have observed, Solana has recently introduced its own mobile phone. In this section, We will outline essential details regarding the Solana Mobile Stack.</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#whats-in-the-solana-mobile-stack","title":"What's in the Solana Mobile Stack?","text":"<p>The Solana Mobile Stack (SMS) is a collection of key technologies for building mobile applications that can interact with the Solana blockchain.</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#mobile-wallet-adapter","title":"Mobile Wallet Adapter\u200b","text":"<p>Mobile Wallet Adapter (MWA) is a protocol specification for connecting mobile dApps to mobile Wallet Apps, enabling communication for Solana transaction and message signing.</p> <p>dApps that implement MWA are able to connect to any compatible MWA Wallet App and request authorization, signing, and sending for transactions/messages.</p> <p>Why this is important: Developers no longer need to build in support for each individual wallet, and instead can just integrate once and use a single unified API to be compatible with every compliant Solana wallet!</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#using-the-sdk","title":"Using the SDK","text":"<p>Solana Mobile maintains an official Mobile Wallet Adapter SDK that implements the protocol, originally written as a Android Kotlin/Java library.</p> <p>The SDK is also ported other frameworks and is available for:</p> <ul> <li>React Native</li> <li>Flutter</li> <li>Unity</li> <li>Unreal Engine</li> </ul>"},{"location":"handbook/appendixA/solana-mobile-phone/#seed-vault","title":"Seed Vault","text":"<p>The Seed Vault is a system service providing secure key custody to Wallet apps. By integrating with secure execution environments available on mobile devices (such as secure operating modes of the processor and/or secure auxiliary coprocessors), Seed Vault helps to keep your secrets safe, by moving them to the highest privileged environment available on the device. Your keys, seeds, and secrets never leave the secure execution environment, while UI components built into Android handle interaction with the user to provide a secure transaction signing experience to users.</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#solana-dapp-store","title":"Solana dApp Store","text":"<p>The Solana dApp Store is an alternate app distribution system, well suited to distributing apps developed by the Solana ecosystem. It will provide a distribution channel for apps that want to establish direct relationships with their customers, without other app stores\u2019 rules restricting the relationship or seeking a large revenue share. The goal of the Solana dApp Store is to empower the Solana community to eventually play a key role in managing the contents of this app store.</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#solana-pay-for-android","title":"Solana Pay for Android","text":"<p>The Solana Pay protocol was developed independently of the Solana Mobile Stack, but combining payments with a mobile device is a natural fit for Solana Pay. The Solana blockchain confirms transactions in less than a second and costs on average $0.0005, providing users a seamless experience with no intermediaries. Businesses and developers can use Solana Pay to accept payments in SOL or any SPL token without intermediaries. It offers frictionless and portable integration options like payment links, pay now buttons or QR codes on your app, dApp, website, blog, and so much more.</p>"},{"location":"handbook/appendixA/solana-mobile-phone/#ecommerce-platform-integrations","title":"eCommerce Platform Integrations","text":"<p>Solana Labs has started a reference implementation for Shopify which you can see here to get a sense of how this might work.</p> <p>Here are some of the top eCommerce platforms that they're looking to integrate to:</p> <ul> <li>WooCommerce</li> <li>Magento</li> <li>BigCommerce</li> <li>Wix</li> <li>Squarespace</li> </ul>"},{"location":"handbook/appendixA/wallets/","title":"Wallets","text":"<p>The Solana ecosystem consists of various user-facing products like wallets and tools that allow anyone to easily create their token or a Non-Fungible Token (NFT) and use the network without much hassle.</p> <p>There are various web wallets, Android and iOS app wallets for smartphones, browser extensions, and also official CLI tools. They differ in capabilities and out-of-the-box support for various Solana projects or being developer-oriented.</p> <p>The major ecosystem wallet providers include:</p> <ul> <li>Phantom (iOS/Android apps and all major browser extensions)</li> <li>Solflare (Web wallet, iOS/Android apps, and chrome-only extension)</li> <li>Sollet (Developer-oriented web wallet and chrome-only extension)</li> <li>Backpack (Web wallet, iOS/Android coming soon)</li> </ul> <p>(At the time of writing, summer 2023)The only supported hardware wallets to safely interact and store keys to access cryptocurrencies and other assets are now Ledger and Trezor products:</p> <ul> <li>Trezor Safe 3</li> <li>Trezor Model T</li> <li>Ledger Nano S</li> <li>Ledger Nano X</li> </ul>"},{"location":"handbook/appendixB/candy-machine/","title":"Candy Machine","text":"<p>The Metaplex Protocol Candy Machine is the leading minting and distribution program for fair NFT collection launches on Solana. Much like its name suggests, you can think of a Candy Machine as a temporary structure which is first loaded by creators and then unloaded by buyers. It allows creators to bring their digital assets on-chain in a secure and customisable way.</p> <p>The name refers to the vending machines that dispense candy for coins via a mechanical crank. In this case the candy are NFTs and the payment is SOL or a SPL token.</p> <p>By September 2022, 78% of all NFTs in Solana were minted through Metaplex\u2019s Candy Machine. This includes most of the well known NFT projects in the Solana ecosystem.</p> <p>Here are some of the features it offers.</p> <ul> <li>Accept payments in SOL, NFTs or any Solana token.</li> <li>Restrict your launch via start/end dates, mint limits, third party signers, etc.</li> <li>Protect your launch against bots via configurable bot taxes and gatekeepers like Captchas.</li> <li>Restrict minting to specific NFT/Token holders or to a curated list of wallets.</li> <li>Create multiple minting groups with different sets of rules.</li> <li>Reveal your NFTs after the launch whilst allowing your users to verify that information.</li> <li>And so much more!</li> </ul> <p></p> <p>For illustrative purposes, we've included the Figure above. However, we won't delve deep into the intricate logic behind the Candy Machine Program, as such a detailed exploration would be too exhaustive for this guide. Our primary aim is to familiarize you with Solana and its burgeoning ecosystem. Those seeking a deeper understanding can delve further into this documentation.</p>"},{"location":"handbook/appendixB/compression/","title":"Compression","text":"<p>Compressed NFTs use State Compression and merkle trees to drastically reduce the storage cost for NFTs (Figure 1.16). Instead of storing an NFT's metadata in a typical Solana account, compressed NFTs store the metadata within the ledger. This allows compressed NFTs to still inherit the security and speed of the Solana blockchain, while at the same time reducing the overall storage costs.</p> <p>Even though the on-chain data storage mechanism is different than their uncompressed counterparts, compressed NFTs still follow the exact same Metadata schema/structure. Allowing you to define your Collection and NFT in an identical way.</p> <p></p> <p>This chart is based on a snapshot taken on April 5, 2023 and based on a price of SOL at $21.14, MATIC at $1.14, and ETH at $1,909.45.</p> <p>State compression is already being used by teams across the Solana ecosystem to power large, user-friendly experiences</p> <ul> <li> <p>Dialect</p> <ul> <li>a blockchain-based messaging service, uses state compression for compressed NFTs to cover the minting cost of NFT stickers to thousands of users.</li> </ul> </li> <li> <p>Crossmint</p> <ul> <li>an NFT and API tooling company, is using state compression to create integrations that power deeper customer loyalty for companies around the world.</li> </ul> </li> </ul> <p>And that\u2019s just the beginning \u2014 projects like user-owned wireless network Helium, NFT distributor DRiP, and on-chain publisher Wordcel, are using state compression to bring their scalable, user-first experiences to Solana.</p> <p>Although state compression can be used to store any sort of data on-chain, the first use of this innovative technology is compressed NFTs. Compressed NFTs are just like regular NFTs, only drastically cheaper \u2014 minting 100 million compressed NFTs costs about \u25ce50 to store on-chain, compared to \u25ce1.2mm for their uncompressed counterpart. In fact, because every incremental compressed NFT is solely a modification of an existing tree, the cost of an NFT on Solana is now as little as the cost of a single transaction (\u25ce0.000005)!</p>"},{"location":"handbook/appendixB/executable-nft/","title":"Executable NFT","text":"<p>Executable NFTs, available in the open beta of new open source wallet Backpack, represent an entirely new way to build applications that are safer, better to use, and in line with the decentralized values blockchain is built on. By combining executable websites and applications that can run locally on a user\u2019s computer with a crypto wallet, xNFTs in Backpack show a promising new type of hybrid web3 application \u2013 not quite an application, not quite a website.</p> <p>xNFTs take a radically practical approach to solving two of web3\u2019s main problems today, decentralization and distribution, with profound implications. While smart contracts run on globally distributed and decentralized networks like Solana, nearly everyone who interacts with smart contracts does so through a website. These centralized, web2 interfaces, and the services that run them, often require the project to register a company, open a bank account, obtain a business debit or credit card, register a domain, and a whole host of other actions just to provide users with a graphical user interface. Each step in that process takes time, money, and adds a potential source of risk for the project\u2019s creators.</p> <p>xNFT Collections unlock whole new avenues for program distribution. A game developer can mint their entire game as limited-edition xNFTs. A DeFi protocol can distribute early access to a new front-end based on wallet addresses. A two-factor code can be generated as an NFT, and automatically cycle through. An artist can create beautiful immersive 3d experiences that can\u2019t be copied, and run directly in the wallet. The possibilities are almost limitless.</p> <p>Because they are, at their core, NFTs, xNFTs can bring a new level of interactivity to traditional collections. The first xNFT Collection, Mad Lads, showcases the power of an executable profile picture collection \u2014 the pictures themselves act as a chatroom for users which is rendered entirely within the NFT.</p> <p>xNFTs are not some new smart contracting language, a scaling solution, or a core technology that will take years to deploy. They exist today. This is just one of the many ecosystem-wide innovations that have supercharged the Solana protocol and greater community.</p> <p></p>"},{"location":"handbook/appendixB/metadata-off-chain/","title":"Storing Metadata Off-chain","text":"<p>One important attribute of the Metadata Account is the URI attribute that points to a JSON file off-chain. This is used to safely provide additional data whilst not being constrained by the fees involved in storing on-chain data. That JSON file follows a certain standard that anyone can use to find useful information on tokens.</p> <p>Note that, this JSON file can be stored using a permanent storage solution such as Arweave to ensure it cannot be updated. Additionally, one can use the Is Mutable attribute of the Metadata Account to make it immutable and, therefore, forbid the URI attribute \u2014 and other attributes such as Name and Creators \u2014 to ever be changed. Using this combination, we can guarantee the immutability of the off-chain JSON file.</p>"},{"location":"handbook/appendixB/metadata-off-chain/#arweave","title":"Arweave","text":"<p>Arweave is a decentralized, trust-minimized, censorship-resistant data storage network designed to retain data permanently, making it a great fit for NFTs. To cover the cost of storing your media forever, storage and mining fees are paid at the time of upload and distributed to storage providers participating in the network.</p> <p>Arweave storage fees:</p> <ul> <li>Storage fees are based on the total size of the files you upload to the network during NFT creation. Each NFT consists of three files         - The asset itself (image, video, audio, etc)         - The accompanying metadata file (attributes etc.)         - A generated manifest which creates a logical grouping or relationship between your files</li> <li>The cumulative size of these files (in bytes) is submitted to the Arweave storage cost estimation service which returns the real time estimated fee for storage, priced in winstons. We then convert the winstons to SOL for payment.</li> </ul>"},{"location":"handbook/appendixB/metadata-off-chain/#other-possibilities","title":"Other possibilities","text":"<ul> <li>AWS S3</li> <li>IPFS</li> <li>NFT.Storage</li> <li>Shadow Drive</li> </ul> <p>For further details, refer to the documentation.</p>"},{"location":"handbook/appendixB/nfts/","title":"Appendix B - NFTs","text":"<p>The phenomenal rise of non-fungible tokens and innovative developments in the NFT landscape have encouraged many people to mint their own NFTs. Solana blockchain has emerged as a popular solution for minting NFTs with its Metaplex platform. The Metaplex is a Solana-based protocol that helps in creating NFTs and auctions. The Candy Machine Metaplex protocol serves as the primary foundation for minting and distribution of NFT collections.</p>"},{"location":"handbook/appendixB/token-metadata-program/","title":"Token Metadata Program","text":"<p>The Token Metadata program is one of the most important programs when dealing with NFTs on the Solana blockchain. Its main goal is to attach (Figure 1.11) additional data to Fungible or Non-Fungible Tokens on Solana.</p> <p>It achieves this using Program Derived Addresses (PDAs) that are derived from the address of Mint Accounts. You should be familiar with Solana\u2019s Token program from SPL (for reminder, Figure 1.10), Mint Accounts are responsible for storing the global information of a Token and Token Accounts store the relationship between a wallet and a Mint Account.</p> <p></p> <p>Whilst Mint Accounts contain a few data attributes such as its current supply, it doesn't offer the ability to inject standardized data that can be understood by apps and marketplaces. This is why the Token Metadata program offers a Metadata Account that attaches itself to a Mint Account via a PDA.</p> <p></p>"},{"location":"handbook/appendixB/token-standard/","title":"Is this all ? \u201cNo, Token Standard\u201d","text":"<p>As token usage has evolved on Solana, it has become clear that there are more types of tokens than simply \"fungible\" and \"non-fungible\" tokens.</p> <p>An example is something the community is calling a \"semi-fungible token\", an SPL token with a supply greater than 1 but which has typical NFT attributes such as an image and an attributes array in the JSON metadata.</p> <p>The consensus seems to be that these should be stored in wallets in the same view as standard NFTs, or in their own view but separate from \"standard\" fungible SPL tokens. These tokens are becoming popular in gaming contexts to support fungible items such as a kind of sword or a piece of wood, etc. but which are in a different league from typical fungible SPL tokens such as USDC.</p> <p>The Token Standard field (in Metadata Account) can have the following values:</p> <ul> <li>NonFungible: A non-fungible token with a Master Edition.<ul> <li>Examples of these are Solana Monkey Business, Stylish Studs and Thugbirdz.</li> </ul> </li> <li>FungibleAsset: A token with metadata that can also have attributes, sometimes called Semi-Fungible.<ul> <li>An example of this kind of token is something the community has been calling \"semi-fungible tokens\" often used to represent a fungible but attribute-heavy in-game item such as a sword or a piece of wood.</li> </ul> </li> <li>Fungible: A token with simple metadata.<ul> <li>USDC, GBTC and RAY.</li> </ul> </li> <li>NonFungibleEdition: A non-fungible token with an Edition account (printed from a Master edition).<ul> <li>very similar to NonFungible (more here).</li> </ul> </li> <li>ProgrammableNonFungible: A special NonFungible token that is frozen at all times to enforce custom authorization rules.<ul> <li>This standard is similar to the Non-Fungible standard above, except that the underlying token account is kept frozen at all times to ensure nobody can transfer, lock or burn Programmable NFTs without going through the Token Metadata program. This enables creators to define custom authorization rules for their NFTs such as enforcing secondary sales royalties.</li> </ul> </li> </ul>"},{"location":"handbook/appendixB/token-standard/#programmable-non-fungible-tokens","title":"Programmable Non-Fungible-Tokens","text":"<p>Because the Token Metadata program builds on top of the Solana Token program, anyone can transfer tokens (fungible or not) without going through the Token Metadata program. In other words, Metadata Account contains field Seller Fee Basis Points, which holds information about secondary sales royalties. The problem is, if we want to transfer tokens (fungible or not), we don't use Metaplex (as its only purpose is to store additional data), however we use SPL for Token Transfer. Whilst there is Seller Fee Basis Points attribute on the Metadata account, it is purely indicative and anyone could create a marketplace that does not honor royalties \u2014 which is exactly what happened.</p> <p>Programmable NFTs were introduced to solve this problem. They are a new opt-in Token Standard that keeps the underlying token accounts frozen at all times. That way, nobody can transfer, lock or burn Programmable NFTs without going through the Token Metadata program.</p> <p>It is then up to the creators to define custom operation-specific authorization rules (Figure 1.14) that will be enforced by the Token Metadata program. These are defined in a special RuleSet account which is attached to the Metadata account. An example of such a RuleSet could be an allowlist of program addresses that honor royalties. RuleSets are part of a new Metaplex program called Token Auth Rules.</p> <p></p>"},{"location":"handbook/appendixB/what-is-metaplex/","title":"What is Metaplex?","text":"<p>Metaplex is a decentralized protocol built on the Solana blockchain designed to simplify the creation, sale, and use of NFTs. By offering a suite of development tools, smart contracts, and open standards, Metaplex enables NFT communities to issue, manage, and own digital assets on-chain.</p> <p>Metaplex continuously develops and maintains several programs and standards to enhance user experience and meet the evolving needs of its community.</p> <p>Currently, major projects are</p> <ul> <li>Token Metadata - the NFT standard for Solana</li> <li>Candy Machine v3\u2122 - a Profile Picture (PFP) focused tool that works like the gumball-style candy machines of old. Candy Machine V3 supports the minting of programmable NFTs.</li> <li>Auction House - a decentralized sales protocol for NFT marketplaces</li> <li>Creator Studio - No-code tools to create, sell, and manage NFTs on Solana.</li> <li>Fixed-Price Sale - A program that enables creators to build/distribute membership NFTs at a fixed-price that grants holders access to exclusive content and events. It supports the restriction of sales to specific collection holders.</li> <li>Compression - A program for creating and interacting with compressed Metaplex NFTs. Compressed NFTs are secured on-chain using Merkle trees.</li> </ul>"},{"location":"handbook/appendixB/what-nfts/","title":"What has this got to do with NFTs?","text":"<p>Well, NFTs are special tokens that are Non-Fungible. More precisely,</p> <p>NFTs on Solana are Mint Accounts with the following characteristics (Figure 1.12):</p> <ul> <li>It has a supply of 1, meaning only one token is in circulation.</li> <li>It has zero decimals, meaning there cannot be such a thing as 0.5 tokens.</li> <li>It has no mint authority, meaning no one can ever mint additional tokens.</li> </ul> <p></p> <p>Metaplex suite offers essential tools for NFT creation on Solana, including the NFT Metadata program itself, minting tools and marketplex, and auction toolkits.</p> <p>Outside of the essential tools, the toolkit also contains many other rather experimental tools like Fireball, Fuse, and Gumball that enable NFT creators to do many different things with their NFTs on Solana.</p>"},{"location":"handbook/appendixB/what-nfts/#master-edition","title":"Master Edition","text":"<p>Additionally, the Token Metadata program offers another account specifically for NFTs called the Master Edition Account (Figure 1.13). This account is also a PDA derived from the Mint Account.</p> <p>Before creating this account, the Token Metadata program will ensure the special characteristics of Non-Fungible Tokens listed above are met. Thus, the existence of the Master Edition account acts as proof of Non-Fungibility for that Mint Account. As shown in Figure 1.13, the Master Edition Account incorporates several fields that haven't been addressed yet. While these fields hold significance, they aren't pivotal for understanding the core principle. In essence, Metaplex offers the capability to create copy of NFTs, wherein the Master Edition, and likewise the Edition Account, functions as evidence of either replication or originality.</p> <p></p>"},{"location":"handbook/appendixC/gaming/","title":"Appendix C - Gaming","text":""},{"location":"handbook/appendixC/gaming/#todo","title":"TODO","text":""},{"location":"handbook/chapter1/block/","title":"Block","text":"<p>Block is a data structure that contains a header comprising three items \u2013 the hash of the previous block\u2019s header, metadata and a Merkle root. Metadata depends on the protocol. The Merkle root is a root of the well-known Merkle tree, which can be used to verify later that transactions in a block have not been tampered with. After the header comes the core part of the block, the transaction.</p>"},{"location":"handbook/chapter1/blockchain/","title":"Blockchain","text":"<p>A blockchain can be thought of as a series of blocks or an append-only data structure that resembles an ordered back-linked linked list, which uses hashes as pointers to previous blocks. This structure consists of blocks that form a chain, hence the term blockchain. It can be easily concluded that it is a very simple data structure.</p> <p></p>"},{"location":"handbook/chapter1/coin/","title":"Coin","text":"<p>Coins motivate participation in the network. They are usually paid with every new block to miners or validators for their help in securing the network. Without the proper incentives, any decentralized blockchain network falls apart.</p>"},{"location":"handbook/chapter1/consensus/","title":"Consensus","text":"<p>To agree on a certain state of a blockchain, network nodes need to reach a consensus. We assume there are malicious nodes in the network. Therefore, the system must be able to withstand not only simple node failures but also attacks to a certain extent. BFT (Byzantine Fault Tolerant) is thus a desired property of such a distributed system. Currently, only three viable consensus families can be used in practice. The first is the classic PBFT-like (Practical BFT) algorithm family. The second is a so-called Nakamoto consensus, which couples a Sybil protection mechanism of Proof-of-Work with the longest-chain rule, a novel consensus invented by Satoshi Nakamoto for Bitcoin in 2008. The third and newest family of consensus protocols known today is called Snow. Yet it is better known by its implementation name \u2013 Avalanche Consensus, introduced in 2018 and used for the Avalanche cryptocurrency.</p>"},{"location":"handbook/chapter1/nodes/","title":"Nodes","text":"<p>Node is a term from graph theory or distributed systems; it is a single participant in a network. The nodes communicate with each other according to the protocol and in a P2P manner forming the whole blockchain network. There might be more types of nodes that are not equal, e.g., validator nodes securing the network or pure RPC (Remote Procedure Call) nodes used only to query the network and post new transactions. Their functions may overlap.</p>"},{"location":"handbook/chapter1/protocol/","title":"Protocol","text":"<p>Protocol is a common set of rules network nodes must follow. It defines things like communication between P2P (Peer-to-Peer) nodes, transaction format for everyone intending to use the network, any special features, and everything else for the network to operate correctly and for the users to know how to transact over the network. An essential part of a good protocol for a decentralized blockchain network is the proper incentive setup; this creates the need for its native coin.</p>"},{"location":"handbook/chapter1/security/","title":"Security","text":"<p>Consensus and Sybil resistance mechanism are often confused as the same thing, which is not true and is worth pointing out. One works in conjunction with the other. Let\u2019s look at how this works in both PoW-based and PoS-based networks. Consider what makes Bitcoin, a PoW-based network, theoretically secure \u2013 it is the fact that only the longest chain is respected, also commonly known as the longest chain rule. This is why the consensus is called, as mentioned before, the Nakamoto consensus. For a PoS-based network, the Sybil resistance mechanism is usually associated with a variant of a PBFT-like algorithm or the novel Avalanche consensus.</p>"},{"location":"handbook/chapter1/smart-contract/","title":"Smart Contract","text":"<p>A smart contract is a piece of code deployed on a blockchain with a cryptographically signed transaction. Users can then interact with it by sending transactions that invoke a specific function defined in the smart contract and the business logic is executed as stated in the deployed code. Data relevant to the smart contract state are also stored on the blockchain. Hence we can look at smart contracts as programs on a decentralized computer that access files in its file system and modify them according to the predefined rules. If such a contract is made immutable, we can trust that the smart contract will not do anything else than what it is supposed to do. It is worth noting that apart from storing the blockchain itself, each node creates a state as a result of transaction execution. The final state is the result of all processed transactions and can always be deterministically recreated from the blockchain history. Code is compiled for a predefined ISA (Instruction Set Architecture) and executed in a VM (Virtual Machine) which understands it. The mentioned VM is a special runtime environment similar to well-known VMs such as JVM (Java Virtual Machine) or CLR (Common Language Runtime) from Microsoft\u2019s .NET ecosystem. The most commonly known VM for smart contracts, which is used by Ethereum, is EVM (Ethereum Virtual Machine); it includes its very own instruction set specialized for the needs of smart contracts. Only transactions involving smart contract execution need to be processed by the VM. The standard execution path is to prepare the relevant smart contract data and smart contract byte code, launch the VM with said data and code, and observe possible failures. If the execution succeeds, the changes to the smart contract data made in the VM are taken, and the state outside the VM is changed; otherwise, the changes are discarded and the next transaction continues.</p>"},{"location":"handbook/chapter1/sybil-resistance/","title":"Sybil Resistance","text":"<p>To prevent a single entity from taking over the network, there must be a mechanism put in place so that no one can just spawn more nodes that can mine or vote (depending on the network) and thus subvert the network reputation system. These dishonest nodes would be able to out-vote honest nodes and start censoring transactions, approving invalid transactions, or changing the entire protocol. Currently, the two most common Sybil resistance mechanisms are PoW (Proof-of-Work) and PoS (Proof-of-Stake). The former employs a model where miners in the network are given a chance to mine a block that is proportional to their hashing power in the network and is used in Bitcoin. The latter is a type of model for voting-based networks, where a validator is given the power of their vote proportionally to staked coins.</p>"},{"location":"handbook/chapter1/transaction/","title":"Transaction","text":"<p>Transaction is a protocol-defined message that is stored as a part of a block, which is then stored as a part of a blockchain. The content usually consists of some kind of value transfer or on-chain program execution. Transactions are cryptographically signed by their authors, proving their authenticity. In the case of a value transfer, ownership of the funds or tokens often represents some value in the real world.</p>"},{"location":"handbook/chapter2/comparison-to-ethereum/","title":"Comparison to Ethereum","text":"<p>Solana is a smart contract platform. Compared to Ethereum, smart contracts on Solana are called Programs. They can be executed in parallel. Parallelization is one of the key differences from other platforms. While Ethereum can be considered a single-threaded distributed computing platform, Solana can be viewed as a multi-threaded one.</p> <p>Solana makes itself clear to focus on improving scalability from the engineering perspective. It is rethinking and reengineering core parts that were first seen in Ethereum and making them parallel and optimized, including the usage of Nvidia CUDA to speed up certain parts of the code and invent its own specialized horizontally scalable database system for state storage and other things that are supposed to make it possible to reach maximum TPS practically only bounded by the network throughput, memory throughput and the number of CUDA cores in modern Nvidia GPUs. Therefore over time, it should scale with better hardware available on the market and internet connectivity in the world.</p>"},{"location":"handbook/chapter2/rust-development/","title":"Rust Development","text":"<p>Solana\u2019s ecosystem revolves around the Rust programming language and its ecosystem. The main and only implementation of the node software is written in it. Also, Solana programs are almost exclusively written in Rust. Although there is no technical barrier preventing from using C or C++, Rust is the most supported language for developing on Solana. All the libraries and supporting code that can be found are written in it, leaving practically no other option.</p>"},{"location":"handbook/chapter2/solana-introduction/","title":"Solana Introduction","text":"<p>Solana, founded by Anatoly Yakovenko in 2017 with the publication of the Solana Whitepaper, introduced Proof-of-History (PoH), a novel mechanism for synchronizing time across distributed systems without mutual trust.</p> <p>The main value proposition of Solana is solving the blockchain trilemma, i.e., delivering scalability, decentralization, and security without sacrificing any of the three mentioned features.</p> <p>Solana officially launched its mainnet in March 2020, with its native coin SOL incentivizing validator nodes and mitigating network spam through transaction fee payments.</p>"},{"location":"handbook/chapter3/archivers/","title":"Archivers \u2013\u2060 Distributed Ledger Storage","text":"<p>Given that the Solana blockchain can grow at enormous speed, considering a full capacity of 1 Gbps (with no overhead) for 365 days, it is roughly 4 petabytes of data that each node would need to store to have a complete history. There is a concept of a distributed ledger storage that would store this data in a decentralized fashion for everyone else.</p> <p>The idea is to offload the data from validators to these specialized network nodes. The data is split into many small pieces and replicated so that the full state can always be reconstructed. These specialized nodes are also contested on the protocol level to ensure they store the data they are supposed to store, and the data loss is prevented.</p> <p>This concept is yet to be implemented. A potential implementation might be using a new decentralized protocol for permanent storage Arweave or Filecoin.</p>"},{"location":"handbook/chapter3/cloudbreak/","title":"Cloudbreak \u2013\u2060 Horizontally-scalable Database","text":"<p>With fast computation, the obvious thing that becomes the new bottleneck is the memory. For example, the industry-standard local database for storing blockchain and state, LevelDB, does not support parallel reads and writes. That is fine for Bitcoin or Ethereum, but not for a massively parallel system like Solana.</p> <p>We could ask the question, why not store everything in RAM? It is too big; even for enterprise machines and large servers, this becomes impossible over time. Therefore Solana had to invent its own database system that supports parallel reads and writes and scales easily with more disks.</p> <p>This new database system is called Cloudbreak and makes use of memory-mapped files. The data is therefore stored in files that can be accessed independently. A memory-mapped file is a file that is mapped to the process\u2019 virtual memory address space and can be accessed directly without further system calls. The speed is still limited by the disk I/O, but we get less overhead, and the kernel can store a part of it in its page cache (also known as file cache).</p> <p>Reads in Cloudbreak are randomly distributed among available disks, as the data is stored evenly. Writes in Cloudbreak use the Copy-on-Write semantics and are appended to a random disk. Hence we get the speed of sequential writing. This is all possible thanks to a clever system of bookkeeping. Old data entries are also garbage collected for future use.</p> <p>The design of Cloudbreak makes it ideal for hardware setups, such as RAID 0 with fast NVMe SSDs. The Cloudbreak database was benchmarked by the Solana team. The results show that even with 10 million accounts (unit of data storage on Solana that will be described in the Programming model), a size that does not fit in the RAM (i.e., cannot be cached by page cache in the kernel), Cloudbreak still achieves reads and writes close to 1 million with a single SSD.</p>"},{"location":"handbook/chapter3/core-concepts/","title":"Core Concepts","text":"<p>There are eight core concepts introduced in Solana that are supposed to make it as fast as developers claim. This section tries to cover them in as much detail as possible. Unfortunately, finding a proper explanation of some of the details is not always possible. Some of these are not yet or not fully implemented, so the source code does not answer the questions that arise while studying them.</p>"},{"location":"handbook/chapter3/gulf-stream/","title":"Gulf Stream \u2013\u2060 Transaction Forwarding Protocol","text":"<p>Gulf Stream is Solana\u2019s mempool-less solution for forwarding and storing transactions before processing them.</p> <p>In traditional blockchains, each node reserves a part of its memory for the memory pool. This memory pool, more commonly referred to as mempool, is used to store transactions currently being broadcasted over the network but have not been processed and added to the blockchain as a part of a new block yet.</p> <p>This implies a huge communication overhead where every transaction must reach every other node in the network. While not everyone necessarily needs to be aware of all transactions in the mempool, they are the most important for miner and validator nodes (depending on the type of a network), which must include them in new blocks.</p> <p>If there are more transactions in the mempool than can fit in the block, the backlog of transactions is created. This can generally lead to increased transaction fees for users who need to push their transaction ahead of other transactions, as it is economically viable for the nodes securing the network to prefer transactions with higher fees. This is currently not possible on Solana, but on the other hand, the network is so fast with its ~400ms block rate that the aim is to process all remaining transactions almost instantaneously anyway.</p>"},{"location":"handbook/chapter3/gulf-stream/#the-solution","title":"The Solution","text":"<p>The solution that Solana devised is to avoid having a single shared mempool and instead push transactions to the edge of the network to the expected leader. The leader receives the transaction as quickly as possible and can process it immediately.</p> <p>However, this solution has a catch. The expected leader must be known ahead. Leaders are known in advance; their rotation is a function of the blockchain data and is known one full epoch before. An epoch is the number of slots for which one leader\u2019s schedule is valid. It is set to 432,000 slots, and with a ~400ms block rate, it takes about two days.</p>"},{"location":"handbook/chapter3/pipelining/","title":"Pipelining \u2013 Transaction Processing Optimizations","text":"<p>It is not enough to be able to form a consensus and share a block with the rest of the network quickly. A node must validate and execute all those transactions in received blocks before another block comes.</p> <p>For this reason, the Solana team developed something called the Transaction Processing Unit (TPU). The TPU works as a processor and extensively uses pipelining, a common CPU optimization that helps keep the chip more utilized by splitting an instruction execution into stages. It is a general way to keep all the hardware parts busy instead of idle. This concept of pipelining was borrowed, and that is how the TPU was born.</p> <p>The pipeline stages of TPU are following (Figure 1.6): - Data fetch in kernel space via network card (I/O) - Signature verification using GPU (very computation heavy if not offloaded) - Change of the state using CPU (banking) - Write to the disk in kernel space and send out via network card (I/O)</p> <p></p> <p>In fact, there are two TPUs in the Solana node software. The one called TPU is used for creating a new block, and the second one, TVU, where the V stands for validator or validation, is used for validating. They may slightly differ. However, the concept and functionality are very similar.</p>"},{"location":"handbook/chapter3/proof-of-history/","title":"Proof-of-History (PoH) \u2013\u2060 Virtual Clocks","text":"<p>Agreement on time in distributed systems has always been problematic. First, a high-level overview of this concept is described, followed by an in-depth description.</p> <p>Solana leverages the so-called Proof-of-History (PoH) mechanism to synchronize local virtual clocks on all nodes. PoH ensures that the timestamp in any message can be trusted and that any timeouts in the consensus protocol can be avoided because everyone knows the time and knows whether to start a new round of consensus or not. PoH allows minimizing the block time as there\u2019s no waiting overhead. In other words, thanks to synchronized clocks, communication can be replaced by local computation.</p> <p>To prevent validators from skipping the validator that comes before them, PoH is used to force all validators to spend a minimum amount of time before they can even submit their block. Thus, if validator B follows validator A, B cannot attempt to skip A by chaining off its previous block because B has to run the Proof-of-History algorithm at least as long as A does, so A gets a fair chance to submit their block.</p>"},{"location":"handbook/chapter3/proof-of-history/#verifiable-delay-function-vdf","title":"Verifiable Delay Function (VDF)","text":"<p>PoH is based on a Verifiable Delay Function (VDF). Specifically, Solana uses a recursive pre-image resistant SHA256 VDF, where the output of one SHA256 iteration is recursively used as the next iteration\u2019s input. To create a block, the producer needs to compute the VDF with all new messages to be included in the block:</p> <pre><code>Message1 \u2192 Hash1\nHash1 + Message2 \u2192 Hash2\nHash2 + Message3 \u2192 Hash3\n\u2026\nHashn-1 + Messagen \u2192 Hashn\n</code></pre>"},{"location":"handbook/chapter3/proof-of-history/#observations","title":"Observations:","text":"<ul> <li>From PoH, we have a proof of the Lower Bound on the time of Messagei (i.e., Messagei must have taken place after Hash<sub>i\u22121</sub>).</li> <li>From PoH, we have a proof of the Upper Bound on the time of Messagei (i.e., Messagei must have taken place before Hash<sub>i</sub>).</li> <li>Points 1 and 2 prove the exact order of the messages, which implies that VDF not only provides us virtual clocks, but everyone can trust the order of events.</li> </ul>"},{"location":"handbook/chapter3/proof-of-history/#phases-of-poh","title":"Phases of PoH:","text":"<ul> <li>Evaluation phase (leader): computation on only one CPU core as it is a strictly sequential computation by definition. This takes:</li> </ul> \\[ \\frac{total\\_number\\_of\\_hashes}{hashes\\_per\\_second\\_for\\_single\\_core} \\] <ul> <li>Verification phase (voters): the block can be checked in parallel using GPU with thousands of cores as it can be easily sliced and the intermediate hashes are known; this takes:</li> </ul> \\[ \\frac{total\\_number\\_of\\_hashes}{hashes\\_per\\_second\\_for\\_single\\_core * number\\_of\\_cores\\_available} \\] <p>Thus, it can be concluded that PoH is difficult to produce but easy to verify. These are two important factors that are crucial for the use of PoH \u2013\u2060 it is not easy to falsify the PoH, but once it is finished, any validator can verify the results very quickly.</p>"},{"location":"handbook/chapter3/sealevel/","title":"Sealevel \u2013\u2060 Parallel Smart Contract Runtime","text":"<p>Other blockchains are single-threaded global state machines. The only thing they might do in parallel is signature verification. Solana introduced Sealevel, a parallelized transaction processing engine designed to scale horizontally across GPUs and SSDs.</p> <p>Sealevel can theoretically process as many transactions as many cores are available to the system. According to the source code, Sealevel is not yet parallelized on the GPU level.</p> <p>This is a major improvement that makes Solana a multi-threaded global state machine, a thing not seen until Solana. Other blockchains, including the leading Ethereum, can be considered single-threaded global state machines because only one smart contract invocation can be processed at a time.</p> <p>The reason this is possible with Solana is that each and every Solana transaction describes all the states required to read and write to. Sealevel can then choose non-overlapping instructions to be executed in parallel and not only that. Transactions that only read certain states can be executed in parallel as well.</p> <p>This is a high-level description of how it works: - Sort millions of pending transactions. - Schedule all the non-overlapping transactions in parallel.</p>"},{"location":"handbook/chapter3/sealevel/#simd-approach-with-gpus","title":"SIMD approach with GPUs","text":"<p>There is a great potential for GPU parallelization and leveraging its SIMD capability. For example, in Nvidia CUDA, modern cards have thousands of CUDA cores and tens of Streaming Multiprocessors.</p> <p>When a CPU invokes a kernel grid, the blocks of threads are distributed among streaming multiprocessors and executed using specific ALU execution units, usually called CUDA cores and other SFUs (special function units).</p> <p>The executed code is the same for all cores. Imagine a situation where there is a single smart contract invocation but with numerous different inputs. This exact workload can be efficiently executed on GPU architectures, such as Nvidia CUDA.</p> <p>Since Sealevel is not yet optimized for GPU offloading, GPUs today are only used to accelerate PoH and signature verification and only if it is available to the system and the algorithm decides it is worth the overhead of launching the kernel grid.</p>"},{"location":"handbook/chapter3/sealevel/#bpf-berkeley-packet-filter","title":"BPF \u2013 Berkeley Packet Filter","text":"<p>There is one important thing that has not been covered in Sealevel yet. What actually executes the code, and how it is done. The standard way is to use some sort of a Virtual Machine (VM) and compile the code for it from any supported language. This code gets deployed to the blockchain, and when the user sends a transaction invoking this contract, the code gets loaded into the VM and executed.</p> <p>Ethereum does this using its own Ethereum Virtual Machine (EVM). Some other blockchains make use of Web Assembly (WASM). Solana iterated through all possible solutions and chose an unexpected VM called Berkeley Packet Filter (BPF).</p> <p>Sealevel hands off transactions to be executed using an industry-proven bytecode called the Berkeley Packet Filter (BPF), designed for high-performance packet filters. It can also be used for non-networking purposes. BPF and the extended BPF (eBPF) are in-kernel VMs available in most UNIX-like operating systems. They are very performant because their primary use was for packet matching, which needs to be as fast as possible. It also has decades of development behind it. The original version of BPF is now called classic BPF (cBPF), and this one could not be used for anything other than packet matching. The Linux kernel now includes only extended BPF (eBPF), a virtual machine with 64-bit registers. The eBPF is now called just BPF.</p> <p>It is worth mentioning that new modern firewalls are being built on top of the extended BPF.  BPF execution is currently parallelized only on the CPU level. What is used is a modified version of BPF called rBPF, which runs in the user space instead of the kernel. This was important as the kernel version of the BPF would not be able to facilitate certain operations.</p>"},{"location":"handbook/chapter3/tower-bft/","title":"Tower BFT (TBFT) \u2013\u2060 PoH-based PBFT","text":"<p>As a consensus algorithm, Solana uses the Tower BFT (TBFT), which is a custom implementation of the well-known Practical Byzantine Fault Tolerance (PBFT) algorithm published in 1999 by Miguel Castro and Barbara Liskov. PBFT consensus rounds are divided into three main phases (pre-prepare, prepare and commit). A detailed description is beyond the scope of this handbook.</p> <p></p> <p>PBFT is focused on satisfying the properties of safety (results are valid and identical at all non-faulty nodes) and liveness (nodes that don\u2019t fail always produce a result). The safety guarantee is possible due to the deterministic nature of the process (executed on every node). The liveness guarantee is possible due to the View-change process. The network will not be stopped unless there are too many byzantine nodes. View-change allows nodes to switch leaders if they appear to be malicious or faulty.</p>"},{"location":"handbook/chapter3/tower-bft/#view-change","title":"View-change","text":"<p>View-changes are carried out when a leader appears to have failed, and so another node attempts to take his place by initiating an election process. It gets triggered by timeouts that prevent nodes from waiting indefinitely for requests to execute. In addition, the timeout is postponed whenever the protocol detects that nodes are reaching an agreement on the current block.</p>"},{"location":"handbook/chapter3/tower-bft/#tbft-vs-pbft","title":"TBFT vs. PBFT","text":"<p>TBFT is a derivation of PBFT, which differs in one fundamental thing. PoH provides a global source of time before consensus is reached and can therefore be used to enforce the exponentially-increasing timeouts introduced in the original PBFT algorithm. No messages are needed as the PoH itself enforces them.</p> <p>The procedure is as follows. Voting on a new block is restricted to a fixed time period counted in hashes, this unit of time is called a slot. At the moment and with the current network settings, if we convert the number of PoH hashes to time, it is approximately 400ms for one slot. Thus every 400ms, a new potential rollback point occurs, but each new block that is voted on doubles the amount of time the network would have to stall before unrolling the original vote.</p> <p>Consider that each validator has voted 32 times in the last few ~12 seconds (32 \u00b7 0.4). The vote 12 seconds ago now has a timeout of 232 slots, which converted to years with a constant time of a slot of 400ms, is roughly 54 years (232 \u00b7 0.4/86400/365). A transaction with 32 confirmations is also considered finalized.</p>"},{"location":"handbook/chapter3/turbine/","title":"Turbine \u2013\u2060 Block Propagation Protocol","text":"<p>Turbine is a name for a smart block propagation protocol that reduces the time needed for block propagation and the overall message complexity reducing the communication overhead of a node.</p> <p>Turbine is a multi-layer propagation protocol. First, nodes in the network are divided into small partitions called neighborhoods. Nodes within a particular neighborhood are responsible for sharing received data with other nodes in the same neighborhood and propagating the data to a small number of nodes in other neighborhoods (Figure 1.3 and 1.4). The data unit shared is called a shred, and one block is constituted of many shreds.</p> <p>The partitioning of nodes into neighborhoods and how exactly are shreds shared within and out of their neighborhoods are implementation details.</p> <p>Since we are in an adversarial environment, any node can decide not to rebroadcast the received shreds or broadcast incorrect data.</p> <p>These two problems are solved with a series of countermeasures:</p> <ul> <li>Forward Error Code (FEC), specifically the Erasure Code, helps by broadcasting a block with more shreds than initially needed to reconstruct the entire block without errors, even if some shreds are lost along the way. With N = 6 data shreds and additional K = 3 shreds, we can lose up to 1/3 of the shreds and still be able to reconstruct the entire block fully.</li> <li>Propagation is prioritized according to their stake. Validators with the most stake are put closer to the current leader. A stake-weighted selection algorithm is used to create a tree where the risk of faulty or malicious nodes is minimized.</li> </ul> <p> </p>"},{"location":"handbook/chapter4/account-anatomy/","title":"Account Anatomy","text":"<p>Just as in UNIX \"everything is a file\", in Solana \"everything is an account\". In other words, an account is a memory buffer, an equivalent of a file in any file system. Its main purpose is to store states between instructions and transactions. An address often referred to as a public key or pubkey, is used to look up an account. Solana\u2019s account system can therefore be considered a key-value database system.</p> <p>The key may be one of the following:</p> <ul> <li>An ed25519 public key.</li> <li>A program-derived account address or in short as PDA (32byte value forced off the ed25519 curve).</li> <li>A hash of an ed25519 public key with a 32-character string</li> </ul> <p>The structure of an account is shown in the following table: </p> <ol> <li>Lamports<ul> <li>Balance of the account in lamports.</li> <li>1 lamport = 10<sup>\u22129</sup> SOL.</li> </ul> </li> <li>Data<ul> <li>Vector of bytes.</li> <li>Maximum size of 10 MB (10 KB for PDAs).</li> </ul> </li> <li>Owner<ul> <li>The owner is a program id or a loader in case of an executable account.</li> <li>If the owner matches the program id, the program is granted write access. Otherwise, it is only permitted to read its data and credit the account.</li> <li>All new accounts are owned by the System program that allows transfers of lamports, allocating data, and assigning ownership to a different program id.</li> <li>An account is always owned by a program or a loader.</li> </ul> </li> <li>Executable<ul> <li>Turning a non-executable account into an executable one is a one-way only operation.</li> <li>The account becomes read-only.</li> <li>The owner of such an account is a loader that will load the code from the data field of the account and start executing it if invoked.</li> </ul> </li> <li>Rent Epoch<ul> <li>For keeping accounts alive on Solana incurs a fee called rent.</li> <li>An account is considered rent-exempt if it holds at least two years\u2019 worth of rent.</li> <li>Rent Epoch is the epoch number when the runtime checks again whether the account should pay rent or is rent-exempt.</li> </ul> </li> </ol>"},{"location":"handbook/chapter4/account-anatomy/#account-types","title":"Account Types","text":"<p>There are three basic types of accounts on Solana. Note that this is not any sort of official classification.</p> <ol> <li>Data accounts storing data or user wallets with an empty data field<ul> <li>Program owned PDA (Program Derived Address) accounts</li> <li>System owned accounts..</li> </ul> </li> <li>Program accounts storing user-deployed executable bytecode.</li> <li>Native accounts indicating native programs or special runtime accounts.<ul> <li>System \u2013 lamports transfers, data allocation and ownership assignment.</li> <li>BPF Loader \u2013 uploading and launching executable programs.</li> <li>BPF Upgradeable Loader \u2013 uploading and launching of upgradeable executable programs.</li> <li>Stake \u2013 program for staking SOL as a part of Proof-of-Stake mechanism.</li> <li>Vote \u2013 program for voting as a part of the Tower BFT consensus.</li> <li>Native Loader \u2013 the owner of native programs and their loader.</li> <li>and more . . .</li> </ul> </li> </ol>"},{"location":"handbook/chapter4/calling-between-programs/","title":"Calling between Programs","text":"<p>Cross Program Invocation (CPI) is a facility that allows us to call other programs from within an instruction. The caller is halted until execution returns from the callee. An important term associated with CPIs is a Program Derived Address (PDA).</p>"},{"location":"handbook/chapter4/calling-between-programs/#program-derived-address-pda","title":"Program Derived Address (PDA)","text":"<p>Programs can issue instructions containing accounts that were not signed in the original transaction by using Program Derived Addresses (PDA). These accounts are called PDA accounts. Program-derived addresses allow programmatically generated signatures to be used when calling between programs.</p> <p>PDA is an address deterministically derived from the program id and supplied keywords or more familiar seeds (Figure 1.8). If needed, the resulting address is checked against the Ed25519 curve and bumped off it with so-called bump seeds. Hence, there is no private key.</p> <p>When a program tries to invoke a CPI with such an address, the runtime takes the supplied keywords and bump seeds, uses the caller\u2019s program id, and repeats the process. If the resulting PDA matches, the account is considered to be signed.</p> <p></p>"},{"location":"handbook/chapter4/communication-with-network/","title":"Communication with Network","text":"<p>Any user who chooses to interact with the network must interact with any of the network\u2019s nodes via a JSON-RPC or a WebSocket endpoint. The available methods are all listed publicly in the Solana documentation.</p> <p>The methods vary from queries, such as specific account information, the network state (example below) to sending transactions.</p> <p>Request of the getBlockHeight method:</p> <pre><code>curl http://localhost:8899 -X POST -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"getBlockHeight\"}'\n</code></pre> <p>Response of the getBlockHeight method:</p> <pre><code>{ \"jsonrpc\": \"2.0\", \"result\": 0, \"id\": 1 }\n</code></pre> <p>What is really important is the ability to send transactions. Sending a transaction is the only way we can change data on the Solana blockchain. Any write operation is done through the means of transactions.</p> <p>Users are not required to use the RPCs directly. There are several libraries that provide convenient interfaces for languages such as Javascript, Rust and Python.</p>"},{"location":"handbook/chapter4/overview/","title":"Overview","text":"<p>The following steps can be thought of as an overview of what happens when an app or any user interacts with the Solana network by sending a transaction. Terms, such as instruction, account, or program, will be explained shortly, followed by a more in-depth explanation.</p> <ul> <li> <p>An app or a user sends a transaction with one or more instructions to a Solana node that accepts RPC requests.</p> </li> <li> <p>The transaction gets validated and forwarded according to the deterministic leader schedule to the next leader.</p> </li> <li> <p>The transaction is validated and processed by the leader and included in a new block, which is then streamed to all other validators who also validate and process the transaction to reach the same final state.</p> </li> <li> <p>During processing, the instructions in the transactions are passed to programs that the developers have deployed in advance. This is the job of the Sealevel runtime. The relevant accounts are modified by code in those programs. Everything happens isolated in the VM. Instructions are executed sequentially and atomically, which means that either all instructions finish successfully or all changes made by any instruction within the transaction are discarded.</p> </li> </ul>"},{"location":"handbook/chapter4/runtime-policy/","title":"Runtime Policy","text":"<p>Runtime policy or Sealevel runtime account rules are a set of rules enforced by the Sealevel runtime to protect the security of the system and make Solana a safe and predictable environment for its users.</p> <p>The following list of rules is taken from the official documentation:</p> <ol> <li>Only the owner of the account may change owner.<ul> <li>And only if the account is writable.</li> <li>And only if the account is not executable.</li> <li>And only if the data is zero-initialized or empty.</li> </ul> </li> <li>An account not assigned to the program cannot have its balance decrease.</li> <li>The balance of read-only and executable accounts may not change.</li> <li>Only the owner may change account size and data.<ul> <li>And if the account is writable.</li> <li>And if the account is not executable.</li> </ul> </li> <li>Executable switch is a one-way (false\u2192true) operation, and only the account owner may set it.</li> <li>No one can make modifications to the rent_epoch associated with this account.</li> </ol>"},{"location":"handbook/chapter4/runtime-policy/#compute-budget","title":"Compute Budget","text":"<p>Each transaction is given a compute budget to prevent abuse of the Solana nodes\u2019 resources that could potentially lead to network failures or denial of service. When the program consumes its entire compute budget or exceeds certain bounds, the runtime halts the currently running instructions and returns an error.</p>"},{"location":"handbook/chapter4/transaction-anatomy/","title":"Transaction Anatomy","text":"<p>A Solana transaction consists of two major parts in the following order:</p> <ul> <li>A compact array of signatures.</li> <li>A message that contains a compact array of account addresses followed by a recent blockhash and ending with a compact array of instructions.</li> </ul> <p></p>"},{"location":"handbook/chapter4/transaction-anatomy/#signatures","title":"Signatures","text":"<p>For signatures in the compact array of signatures, the Solana runtime verifies the following:</p> <ul> <li>The number of signatures must match the first 8 bits of the message header.</li> <li>The signature is verified against the public key at the same index in the message\u2019s account addresses array.</li> </ul>"},{"location":"handbook/chapter4/transaction-anatomy/#message","title":"Message","text":"<p>The message layout is shown in the following table:</p> <p></p> <ol> <li>Header<ul> <li># of required signatures in the transaction (8 bits).</li> <li># of read-only accounts requiring signatures (8 bits).</li> <li># of read-only accounts not-requiring signatures (8 bits).</li> </ul> </li> <li>Accounts<ul> <li>Addresses that require signatures with read-write access.</li> <li>Addresses that require signatures with read-only access.</li> <li>Addresses that do not require signatures with read-write access.</li> <li>Addresses that do not require signatures with read-only access.</li> </ul> </li> <li>Recent blockhash<ul> <li>Transaction lifetime: transaction is deemed invalid if the blockhash is older than 32 blocks.</li> <li>Transaction replay: identical txs get rejected, the blockhash can be changed and the exact same action repeated. It works in a similar way as nonce in Ethereum.</li> </ul> </li> <li>Instructions with the following instruction anatomy:<ul> <li>Program id index.</li> <li>Compact-array of account address indices (indices to Accounts).</li> <li>Compact-array of opaque 8-bit data (what operations to perform and any additional data).</li> </ul> </li> </ol> <p></p>"},{"location":"handbook/chapter4/transaction-key-elements/","title":"Transaction Key Elements","text":"<p>Signature - Each digital signature is in the ed25519 binary format consuming 64 bytes.</p> <p>Account - A record in the Solana ledger that either holds data or is an executable program.</p> <p>Compact Array - An array-like data structure that begins with a specially encoded array length in the first 16 bits, followed by the array items.</p> <p>Blockhash - A unique hash that identifies a block produced as a part of the Proof-of-History algorithm.</p> <p>Program id - The address (public key) of an account containing a program.</p> <p>Instruction - A structure specifying a program id for execution, relevant accounts, and opaque instruction data that the program can interpret.</p>"},{"location":"handbook/chapter5/account-compression-program/","title":"Account Compression Program","text":"<p>The Account Compression Program is an innovative on-chain system designed to alleviate the rising concern of storage costs on the Solana blockchain. Its main application revolves around the utilization of SPL ConcurrentMerkleTrees, allowing for the on-chain verification of off-chain data edits. This innovative solution has been crafted in response to the challenges brought about by the increased creation of Non-Fungible Tokens (NFTs) on the Solana blockchain.</p>"},{"location":"handbook/chapter5/account-compression-program/#motivation","title":"Motivation","text":"<ul> <li>Solana's high throughput has fostered a significant increase in the creation of NFTs. The attractive features of NFTs, such as custodial ownership and censorship resistance, have contributed to their popularity. However, this widespread adoption has led to a critical concern: the network storage costs when creating NFTs at scale.</li> <li>While minting a single non-fungible token may be relatively inexpensive, the cost of storing the asset's data on-chain can quickly become uneconomical as the quantity increases. This issue presents a barrier to the practical and widespread use of NFTs, especially when they are produced en masse.</li> <li>The objective is to make the cost per token as close to zero as possible, ensuring affordability and scalability. The solution lies in storing a compressed hash of the asset data on-chain, while the actual data resides off-chain in a database.</li> <li>The Account Compression Program facilitates this by providing a means to verify the off-chain data on-chain and enabling concurrent writes to the data. A central component of this solution is the Concurrent Merkle Tree, a newly introduced data structure that prevents proof collision during concurrent writes.</li> </ul>"},{"location":"handbook/chapter5/account-compression-program/#application","title":"Application","text":"<p>The Account Compression Program is already in use in projects like the Metaplex Bubblegum Program. Its implementation has allowed for a reduction in on-chain storage costs, making it more economical to produce and manage NFTs at scale.</p>"},{"location":"handbook/chapter5/associated-token-acc-program/","title":"Associated Token Account Program","text":"<p>This program defines the convention and provides the mechanism for mapping the user's wallet address to the associated token accounts they hold.</p>"},{"location":"handbook/chapter5/associated-token-acc-program/#motivation","title":"Motivation","text":"<ul> <li> <p>A user may own arbitrarily many token accounts belonging to the same mint which makes it difficult for other users to know which account they should send tokens to and introduces friction into many other aspects of token management. This program introduces a way to deterministically derive a token account key from a user's main System account address and a token mint address, allowing the user to create a main token account for each token they own. We call these accounts Associated Token Accounts.</p> </li> <li> <p>In addition, it allows a user to send tokens to another user even if the beneficiary does not yet have a token account for that mint. Unlike a system transfer, for a token transfer to succeed the recipient must have a token account with the compatible mint already, and somebody needs to fund that token account. If the recipient must fund it first, it makes things like airdrop campaigns difficult and just generally increases the friction of token transfers. The Associated Token Account program allows the sender to create the associated token account for the receiver, so the token transfer just works.</p> </li> </ul>"},{"location":"handbook/chapter5/solana-program-library/","title":"Solana Program Library","text":"<p>The Solana Program Library (SPL) is a collection of on-chain programs such as SPL-Token that facilitates tasks such as creating and using tokens and a lot more.</p>"},{"location":"handbook/chapter5/token-2022/","title":"Token 2022 Program","text":"<p>The Token-2022 Program extends the functionality provided by the Token Program. This means that the Token-2022 program is backward compatible and includes all the functions of the original Token program, as well as additional functionality often referred to as token extensions. You can think of the extensions as a series of options, features, and capabilities built into the newest iteration of the Solana token program.</p>"},{"location":"handbook/chapter5/token-2022/#benefits","title":"Benefits","text":"<ul> <li>Flexibility: Token issuers can choose to enable any combination of token extensions.</li> <li>Reduced risk: Using audited and well-tested extensions reduces attack vectors and helps to protect protocols and funds.</li> <li>Reduced testing costs: Because the extensions are added by simply specifying the extensions in your code, the chances of defects and human error are greatly reduced, saving on testing time and costs.</li> <li>Reduced development time: Because the extensions are uniform and reusable, the time required to develop applications using the extensions is significantly reduced.</li> </ul>"},{"location":"handbook/chapter5/token-2022/#extensions","title":"Extensions","text":"<p>Extensions can be of two types: mint and account extensions. All of these extensions can be used out-of-the-box.</p> <p>Mint extensions are added on top of the original Solana Token Program and extend the abilities of tokens. Account extensions are added on top of Solana accounts and add account-related features.</p> <p>Current mint extensions include 14 extensions. Some of the most important are:</p> <ul> <li>Confidential transfers: Allow confidential transfers between participating users without revealing the amount of the transfer.</li> <li>Transfer fees: Allow transfer fees to be charged on each transfer and sent to a defined account.</li> <li>Mint close authority: Allows owners to close mint accounts and reclaim the lamports on the mint account.</li> <li>Transfer hook: Allows calling specific programs with each token transfer.</li> </ul> <p>Current account extensions include:</p> <ul> <li>Memo required on transfer: Requires an attached memo as a message during each token transfer. This could be used for regulatory compliance, reporting, and enhanced audit trails. Immutable owner: Makes it impossible to reassign ownership of an account.</li> <li>Default account state: Freezes all new token accounts so that users must interact with the project in some way to unfreeze the accounts/tokens.</li> <li>CPI guard: Restricts how other programs can interact with your token by prohibiting certain actions inside cross-program invocations.</li> <li>Reallocate: Some extensions can be enabled after account creation. Reallocate allows owners in this situation to reallocate their token account to create room for more extensions. For a complete explanation and guide about the Token 2022 Program and its extensions see.</li> </ul>"},{"location":"handbook/chapter5/token-program/","title":"Token Program","text":"<p>A Token program on the Solana blockchain. This program defines a common implementation for Fungible and Non Fungible tokens.</p> <p>All tokens on Solana, whether they are fungible tokens or NFTs (see Figure 1.9), are created using the SPL Token Program. If you\u2019re familiar with Ethereum, you can think of SPL tokens as a token standard such as ERC-20 or ERC-721. One key difference, however, is that Solana does not require you to deploy a new contract for each token you create. Instead, it simply requires you to send instructions to the Token Program and it will create and mint tokens on your behalf.</p> <p></p>"},{"location":"handbook/chapter5/token-program/#creating-a-new-token","title":"Creating a new Token","text":"<p>A new Token can be created by initializing a new Mint with the InitializeMint instruction. The Mint is used to create or \"mint\" new tokens, and these tokens are stored in Accounts. A Mint is associated with each Account, which means that the total supply of a particular token type is equal to the balances of all the associated Accounts (see Figure 1.9 for mentioned fields).</p> <p>Once a Mint is initialized, the mint_authority can create new tokens using the MintTo instruction. As long as a Mint contains a valid mint_authority, the Mint is considered to have a non-fixed supply, and the mint_authority can create new tokens with the MintTo instruction at any time.</p>"},{"location":"handbook/chapter5/token-program/#transferring-tokens","title":"Transferring Tokens","text":"<p>Balances can be transferred between Accounts using the Transfer instruction. The owner of the source Account must be present as a signer in the Transfer instruction when the source and destination accounts are different.</p> <p>The image provided below depicts the process of token transfer. Further information about Associated Token Accounts (ATA) will be covered in subsequent sections.</p>"},{"location":"handbook/chapter5/token-program/#burning-tokens","title":"Burning Tokens","text":"<p>The Burn instruction decreases an Account's token balance without transferring to another Account, effectively removing the token from circulation permanently.</p> <p>There is no other way to reduce supply on chain. This is similar to transferring to an account with an unknown private key or destroying a private key. But the act of burning by using Burn instructions is more explicit and can be confirmed on chain by any parties.</p>"},{"location":"handbook/chapter5/token-program/#freezing-accounts","title":"Freezing Accounts","text":"<p>The Mint may also contain a freeze_authority which can be used to issue FreezeAccount instructions that will render an Account unusable. Token instructions that include a frozen account will fail until the Account is thawed using the ThawAccount instruction. The SetAuthority instruction can be used to change a Mint's freeze_authority.</p>"},{"location":"handbook/chapter5/token-program/#wrapping-sol","title":"Wrapping Sol","text":"<p>The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.</p> <p>Accounts containing wrapped SOL are associated with a specific Mint called the \"Native Mint\"</p> <p>These accounts have a few unique behaviors:</p> <ul> <li>InitializeAccount sets the balance of the initialized Account to the SOL balance of the Solana account being initialized, resulting in a token balance equal to the SOL balance.</li> <li>Transfers to and from not only modify the token balance but also transfer an equal amount of SOL from the source account to the destination account.</li> <li>Burning is not supported</li> <li>When closing an Account the balance may be non-zero.</li> </ul>"},{"location":"handbook/chapter5/token-program/#non-fungible-tokens","title":"Non-Fungible Tokens","text":"<p>An NFT is simply a token type where only a single token has been minted. A more comprehensive discussion about NFTs is conducted in Appendix B.</p>"}]}